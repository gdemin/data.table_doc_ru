[
["index.html", "Руководство по data.table", " Руководство по data.table Андрей Огурцов 2016-09-12 Вступление Данное руководство содержит переводы всех виньеток по пакету data.table. Все, кроме последней, переведены с версий от июня 2015 г.; последняя - с версии от апреля 2016 г. Переводы будут актуализироваться, также планируется добавить другие материалы. GitHub "],
["01_data.table_intro.html", "1 Введение в data.table 1.1 Анализ данных с data.table 1.2 Данные 1.3 Введение 1.4 1. Основы 1.5 2. Агрегирования 1.6 Резюме", " 1 Введение в data.table Эта виньетка представляет собой введение в синтаксис data.table, его общий вид, способы создания поднаборов строк (subset), выбора и вычисления колонок (select, compute), агрегирования по группам (by group). Знакомство с базовой структурой данных data.frame является полезным, но не обязательным. 1.1 Анализ данных с data.table Все операции манипулирования данными, такие как subset, group, update, join и др., по сути взаимосвязаны. С учетом этого, вместе они обеспечивают: краткий и согласованный синтаксис независимо от набора операций, которые вы хотели бы выполнить для достижения вашей конечной цели. плавное выполнение анализа без когнитивной нагрузки, связанной с помещением каждой операции в отдельную функцию из набора доступных функций для выполнения анализа. автоматическая и эффективная внутренняя оптимизация за счет точного знания, какие данные нужны для каждой операции, что делает вычисления очень быстрыми и экономно расходующими память. Вкратце, если вы заинтересованы в радикальном сокращении программного кода и времени вычислений, то этот пакет для вас. Философия, которой следует data.table, делает это возможным. Наша цель состоит в иллюстрации этого в серии виньеток. 1.2 Данные В этой виньетке мы используем набор данных NYC-flights14. Он содержит данные о времени полетов от Bureau of Transporation Statistics для всех рейсов из аэропортов Нью-Йорка в 2014 г. (по аналогии с nycflights13). Данные доступны только с января по октябрь 2014 г. Мы можем использовать быструю функцию для чтения fread из data.table для непосредственной загрузки набора данных flights: flights &lt;- fread(&quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/flights/NYCflights14/flights14.csv&quot;) flights # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 # 4: 2014 1 1 722 -8 1014 -26 0 AA N3EHAA 29 # 5: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 # --- # 253312: 2014 10 31 1459 1 1747 -30 0 UA N23708 1744 # 253313: 2014 10 31 854 -5 1147 -14 0 UA N33132 1758 # 253314: 2014 10 31 1102 -8 1311 16 0 MQ N827MQ 3591 # 253315: 2014 10 31 1106 -4 1325 15 0 MQ N511MQ 3592 # 253316: 2014 10 31 824 -5 1045 1 0 MQ N813MQ 3599 # origin dest air_time distance hour min # 1: JFK LAX 359 2475 9 14 # 2: JFK LAX 363 2475 11 57 # 3: JFK LAX 351 2475 19 2 # 4: LGA PBI 157 1035 7 22 # 5: JFK LAX 350 2475 13 47 # --- # 253312: LGA IAH 201 1416 14 59 # 253313: EWR IAH 189 1400 8 54 # 253314: LGA RDU 83 431 11 2 # 253315: LGA DTW 75 502 11 6 # 253316: LGA SDF 110 659 8 24 dim(flights) # [1] 253316 17 Так как мы будем использовать этот набор данных во всех виньетках, может быть, лучше скачать файл один раз и затем загружать его с диска. 1.3 Введение В этой виньетке мы: начнем с основ - что такое пакет data.table, его общий вид, способы выделения поднаборов строк, выбор и вычисление колонок затем перейдем к выполнению агрегирования данных по группам. 1.4 1. Основы 1.4.1 a) Что такое data.table? data.table является пакетом, обеспечивающим улучшенную версию таблиц данных data.frames. В разделе “Данные” мы уже создали таблицу data.table при помощи fread(). Мы также можем создать таблицу, используя функцию data.table(). Пример: DT = data.table(ID = c(&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;,&quot;c&quot;), a = 1:6, b = 7:12, c=13:18) DT # ID a b c # 1: b 1 7 13 # 2: b 2 8 14 # 3: b 3 9 15 # 4: a 4 10 16 # 5: a 5 11 17 # 6: c 6 12 18 class(DT$ID) # [1] &quot;character&quot; Вы также можете конвертировать существующие объекты в data.table, используя as.data.table(). 1.4.1.1 Обратите внимание, что: В отличие от data.frames, столбцы символьного типа по умолчанию никогда не конвертируются в факторы (factor). Номера строк выводятся вместе с : для их визуального отделения от первого столбца. Когда количество строк для вывода превышает значение глобального параметра datatable.print.nrows (по умолчанию оно равно 100), автоматически выводятся только первые 5 и последние 5 строк (как можно видеть в разделе “Данные”). getOption(&quot;datatable.print.nrows&quot;) # [1] 100 data.table никогда не устанавливает имена строк (row names). Почему - мы увидим в виньетке “Keys and fast binary search based subset”. 1.4.2 b) Общий вид - каким образом реализованы улучшения data.table? По сравнению с data.frame, мы можете сделать гораздо больше, чем выбор строк и столбцов в таблице при помощи [ ... ]. Для понимания этого посмотрим на общий вид синтаксиса data.table, как показано ниже: DT[i, j, by] ## R: i j by ## SQL: where select | update group by Пользователи с опытом использования SQL могут сразу понять этот синтаксис. 1.4.2.1 Как прочитать это (вслух): Взять DT, выбрать строки при помощи i, затем вычислить j, сгруппировав по by. Давайте начнем с рассмотрения i и j - выбора строк и операций над столбцами. 1.4.3 c) Выбор строк в i 1.4.3.1 - Выбрать все рейсы с начальной точкой (аэропортом) “JFK” за июнь. ans &lt;- flights[origin == &quot;JFK&quot; &amp; month == 6L] head(ans) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 6 1 851 -9 1205 -5 0 AA N787AA 1 JFK # 2: 2014 6 1 1220 -10 1522 -13 0 AA N795AA 3 JFK # 3: 2014 6 1 718 18 1014 -1 0 AA N784AA 9 JFK # 4: 2014 6 1 1024 -6 1314 -16 0 AA N791AA 19 JFK # 5: 2014 6 1 1841 -4 2125 -45 0 AA N790AA 21 JFK # 6: 2014 6 1 1454 -6 1757 -23 0 AA N785AA 117 JFK # dest air_time distance hour min # 1: LAX 324 2475 8 51 # 2: LAX 329 2475 12 20 # 3: LAX 326 2475 7 18 # 4: LAX 320 2475 10 24 # 5: LAX 326 2475 18 41 # 6: LAX 329 2475 14 54 В таблице data.table к столбцам можно обращаться, как если бы они были переменными. Таким образом, мы просто обратились к dest (origin в примере выше - прим. пер.) и month как к переменным. Нам не нужно каждый раз добавлять префикс flights$. Тем не менее, использование flights$dest и flights$month будет нормально работать. Были рассчитаны индексы строк, удовлетворяющих условию origin == &quot;JFK&quot; &amp; month == 6L, и, поскольку больше ничего делать не нужно, data.table просто возвратил все столбцы flights в соответствии с этими индексами строк. Запятая после условия также не требуется в составе i. Но flights[dest == &quot;JFK&quot; &amp; month == 6L, ] также будет нормально работать. В data.frames, тем не менее, запятая обязательна. 1.4.3.2 - Выбрать первые две строки из таблицы flights. ans &lt;- flights[1:2] ans # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 JFK # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 JFK # dest air_time distance hour min # 1: LAX 359 2475 9 14 # 2: LAX 363 2475 11 57 В этом случае условия нет. Индексы строк уже предоставлены в составе i. Поэтому мы возвращаем data.table со всеми столбцами из flights для этих индексов строк. 1.4.3.3 - Упорядочить flights сначала по столбцу origin в порядке возрастания, а затем по dest в порядке убывания. Мы можем использовать для этого базовую функцию R order(). ans &lt;- flights[order(origin, -dest)] head(ans) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 5 836 6 1151 49 0 EV N12175 4419 EWR # 2: 2014 1 6 833 7 1111 13 0 EV N24128 4419 EWR # 3: 2014 1 7 811 -6 1035 -13 0 EV N12142 4419 EWR # 4: 2014 1 8 810 -7 1036 -12 0 EV N11193 4419 EWR # 5: 2014 1 9 833 16 1055 7 0 EV N14198 4419 EWR # 6: 2014 1 13 923 66 1154 66 0 EV N12157 4419 EWR # dest air_time distance hour min # 1: XNA 195 1131 8 36 # 2: XNA 190 1131 8 33 # 3: XNA 179 1131 8 11 # 4: XNA 184 1131 8 10 # 5: XNA 181 1131 8 33 # 6: XNA 188 1131 9 23 1.4.3.4 Функция order() является внутренне оптимизированной Мы можем использовать “-” перед именем столбца в таблице data.table для сортировки в порядке убывания. Кроме того, order(...) в таблице data.table использует внутренний способ упорядочивания forder(), который гораздо быстрее, чем base::order. Вот небольшой пример, чтобы проиллюстрировать разницу. odt = data.table(col=sample(1e7)) (t1 &lt;- system.time(ans1 &lt;- odt[base::order(col)])) ## uses order from base R # user system elapsed # 8.610 0.056 8.708 (t2 &lt;- system.time(ans2 &lt;- odt[order(col)])) ## uses data.table&#39;s forder # user system elapsed # 0.526 0.024 0.553 (identical(ans1, ans2)) # [1] TRUE Ускорение составило ~16x. Мы обсудим быстрое упорядочивание в виньетке “data.table internals”. Таким образом, вы можете улучшить производительность, используя хорошо знакомые функции. 1.4.4 d) Выбор столбцов в j 1.4.4.1 - Выбрать столбец arr_delay, но вернуть как вектор. ans &lt;- flights[, arr_delay] head(ans) # [1] 13 13 9 -26 1 0 Поскольку можно обращаться к столбцам, как если бы они были переменными в таблице, мы напрямую обратились к переменным, которые хотим выбрать. Поскольку нам нужны все строки, мы просто пропустили i. Были возвращены все строки для столбца arr_delay. 1.4.4.2 - Выбрать столбец arr_delay, но вернуть как data.table. ans &lt;- flights[, list(arr_delay)] head(ans) # arr_delay # 1: 13 # 2: 13 # 3: 9 # 4: -26 # 5: 1 # 6: 0 Мы обернули переменные (имена столбцов) вызовом list(), что гарантирует возврат объекта data.table. В случае отдельного имени столбца, не обернутого в list(), вместо этого возвращается вектор, как было показано в предыдущем примере. data.table также позволяет использовать .(). Это псевдоним (alias) для list(). Используйте тот или иной вариант в зависимости от своих предпочтений. Далее мы продолжим использовать .(). data.tables (и data.frames) внутри являются списками со столбцами равной длины и с атрибутом класса. Разрешение j возвращать список позволяет конвертировать и возвращать data.table очень эффективно. 1.4.4.3 Совет Поскольку j-выражение возвращает список, каждый элемент списка будет сконвертирован в столбец итоговой таблицы data.table. Это делает j допольно мощным средством, как мы вскоре увидим. 1.4.4.4 - Выбрать столбцы arr_delay и dep_delay. ans &lt;- flights[, .(arr_delay, dep_delay)] head(ans) # arr_delay dep_delay # 1: 13 14 # 2: 13 -3 # 3: 9 2 # 4: -26 -8 # 5: 1 2 # 6: 0 4 ## alternatively # ans &lt;- flights[, list(arr_delay, dep_delay)] Оберните обе колонки в .() или list(). Вот и все. 1.4.4.5 - Выбрать столбцы arr_delay и dep_delay и переименовать их в delay_arr и delay_dep. ans &lt;- flights[, .(delay_arr = arr_delay, delay_dep = dep_delay)] head(ans) # delay_arr delay_dep # 1: 13 14 # 2: 13 -3 # 3: 9 2 # 4: -26 -8 # 5: 1 2 # 6: 0 4 Вот и все. 1.4.5 e) Вычислить или выполнить в j 1.4.5.1 – сколько рейсов имели общую задержку (delay) &lt; 0? ans &lt;- flights[, sum((arr_delay + dep_delay) &lt; 0)] ans # [1] 141814 1.4.5.2 Что здесь происходит? j в data.table может не только выбирать столбцы - этот элемент может обрабатывать выражения, т.е. вычислять столбцы. Это не удивительно, ведь к столбцам можно обращаться, как к переменным. Тогда мы должны быть способны выполнять вычисления, вызывая функции для этих переменных. И это именно то, что здесь происходит. 1.4.6 f) Выбрать в i и выполнить в j 1.4.6.1 - Рассчитать среднюю задержку прибытия и отлета для всех рейсов с начальной точкой (аэропортом) “JFK” за июнь. ans &lt;- flights[origin == &quot;JFK&quot; &amp; month == 6L, .(m_arr=mean(arr_delay), m_dep=mean(dep_delay))] ans # m_arr m_dep # 1: 5.839349 9.807884 Мы сперва выбрали строки в i, найдя индексы, для которых значение origin равно “JFK”, а значение month равно 6. В этот момент мы не выбрали часть целой таблицы data.table, соответствующую этим строкам. Теперь мы смотрим на j и видим, что это выражение использует только два столбца. И мы должны рассчитать их средние значения mean(). Поэтому мы выбираем только столбцы с соответствующими строками и рассчитываем mean(). Поскольку три компонента запроса (i, j и by) находятся вместе внутри [...], data.table может видеть все три и оптимизировать запрос целиком перед вычислением, а не каждый по отдельности. Следовательно, мы можем избежать выбора всего поднабора данных для большей скорости и эффективного использования памяти. 1.4.6.2 - Как много рейсов было сделано в 2014 г. из аэропорта “JFK” за июнь? ans &lt;- flights[origin == &quot;JFK&quot; &amp; month == 6L, length(dest)] ans # [1] 8422 Функция length() требует передачи ей аргумента. Нам нужно лишь рассчитать количество строк в поднаборе. На самом деле, вы могли бы использовать любой столбец в качестве аргумента length(). Этот тип операций встречается довольно часто, особенно в процессе группировки, как мы увидим в следующем разделе. data.table предоставляет для этого специальный символ .N. 1.4.6.3 Специальный символ .N .N является специальной встроенной переменной, которая содержит число наблюдений в данной группе. Это особенно полезно в сочетании с by, как мы увидим в следующем разделе. При отсутствии операции группировки просто возвращает количество строк в поднаборе. Так что теперь мы можем выполнить эту задачу с помощью .N следующим образом: ans &lt;- flights[origin == &quot;JFK&quot; &amp; month == 6L, .N] ans # [1] 8422 Еще раз: мы выбираем поднабор в i для получения индексов строк, для которых значение origin равно “JFK”, а значение month равно 6. Мы видим, что j использует только .Nи не использует никаких столбцов. Поэтому весь поднабор не “материализовался”. Мы просто вернули число строк в поднаборе (которое является всего лишь длиной индекса строк). Обратите внимание, что мы не обернули .N в list() или в .(), поэтому возвращен вектор. Мы могли бы выполнить ту же операцию при помощи nrow(flights[origin == &quot;JFK&quot; &amp; month == 6L]). Тем не менее, это привело бы сначала к выбору поднабора всей таблицы data.table для соответствующих индексов строк в i, а затем возврату числа строк при помощи nrow(), что является ненужным и неэффективным. Мы подробно рассмотрим этот и другие аспекты оптимизации в виньетке “data.table design”. 1.4.7 g) Отлично! Но как я могу ссылаться на столбцы по именам в j (как в data.frame)? Вы можете ссылаться на имена столбцов в стиле data.frame, используя with = FALSE (таким же образом можно передавать номера столбцов - прим. пер.). 1.4.7.1 – Выбрать столбцы arr_delay и dep_delay, как в data.frame. ans &lt;- flights[, c(&quot;arr_delay&quot;, &quot;dep_delay&quot;), with=FALSE] head(ans) # arr_delay dep_delay # 1: 13 14 # 2: 13 -3 # 3: 9 2 # 4: -26 -8 # 5: 1 2 # 6: 0 4 Этот аргумент назван with, как функция R with(), из-за подобной функциональности. Предположим, у вас есть data.frame DF, и вы хотите выбрать все строки, для которых x &gt; 1. DF = data.frame(x = c(1,1,1,2,2,3,3,3), y = 1:8) ## (1) normal way DF[DF$x &gt; 1, ] # data.frame needs that &#39;,&#39; as well # x y # 4 2 4 # 5 2 5 # 6 3 6 # 7 3 7 # 8 3 8 ## (2) using with DF[with(DF, x &gt; 1), ] # x y # 4 2 4 # 5 2 5 # 6 3 6 # 7 3 7 # 8 3 8 Использование with() в (2) позволяет использовать столбец x в DF как переменную. Отсюда и название аргумента в data.table. Установка with=FALSE отключает возможность ссылаться на столбцы как на переменные, тем самым восстанавливая “режим data.frame по умолчанию”. Мы также можем исключать столбцы при помощи - или !. Например: ## not run # returns all columns except arr_delay and dep_delay ans &lt;- flights[, !c(&quot;arr_delay&quot;, &quot;dep_delay&quot;), with=FALSE] # or ans &lt;- flights[, -c(&quot;arr_delay&quot;, &quot;dep_delay&quot;), with=FALSE] Начиная с v1.9.5+, мы также можем выбирать с указанием начального и конечного имен столбцов, например, year:day выберет первые три столбца. ## not run # returns year,month and day ans &lt;- flights[, year:day, with=FALSE] # returns day, month and year ans &lt;- flights[, day:year, with=FALSE] # returns all columns except year, month and day ans &lt;- flights[, -(year:day), with=FALSE] ans &lt;- flights[, !(year:day), with=FALSE] Это особенно удобно при работе в интерактивном режиме. with = TRUE установлено по умолчанию в data.table, потому что мы можем сделать гораздо больше, позволяя j обрабатывать выражения - особенно в комбинации с by, что мы сейчас увидим. 1.5 2. Агрегирования Мы уже видели общую форму i и j из data.table в предыдущем разделе. В этом разделе мы увидим, как они могут сочетаться с by для выполнения операций по группам. Давайте рассмотрим несколько примеров. 1.5.1 a) Группировка с использованием by 1.5.1.1 - Как мы можем получить количество рейсов, соответствующее каждому аэропорту отправления? ans &lt;- flights[, .(.N), by=.(origin)] ans # origin N # 1: JFK 81483 # 2: LGA 84433 # 3: EWR 87400 ## or equivalently using a character vector in &#39;by&#39; # ans &lt;- flights[, .(.N), by=&quot;origin&quot;] Мы знаем, что .N является специальной переменной, содержащей количество строк в данной группе. Группировка по origin позволяет получить количество строк, .N, для каждой группы. Выполнив head(flights), вы увидите, что аэропорты идут в последовательности “JFK”, “LGA” и “EWR”. Исходная последовательность группирующих переменных сохраняется в результате. Так как мы не указали в j имя для вовращаемого столбца, он был автоматически назван N из-за распознавания специального символа .N. by также принимает символьный вектор из имен столбцов. Это особенно полезно для программ, содержащих, например, проектирование функции со столбцами для группировки в качестве аргумента. Когда есть только один столбец или выражение в j и by, мы можем отбросить запись .() для удобства. Мы могли бы вместо этого выполнить: ans &lt;- flights[, .N, by=origin] ans # origin N # 1: JFK 81483 # 2: LGA 84433 # 3: EWR 87400 Мы будем использовать в будущем эту удобную форму, где это применимо. 1.5.1.2 - Как мы можем рассчитать количество рейсов из каждого аэропорта отправления для авиаперевозчика с кодом “AA”? Уникальный код авиаперевозчика “AA” соответствует American Airlines Inc. ans &lt;- flights[carrier == &quot;AA&quot;, .N, by=origin] ans # origin N # 1: JFK 11923 # 2: LGA 11730 # 3: EWR 2649 Сперва мы получаем индексы строк для выражения carrier == &quot;AA&quot; в i. Используя эти индексы строк, мы получаем количество строк для группировки по origin. И снова никакие столбцы на самом деле здесь не “материализуются”, потому что j-выражение не требует наличия столбцов, для которых выполнено создание поднабора, и поэтому оно работает быстро и эффективно расходует память. 1.5.1.3 - Как мы можем получить количество рейсов для каждой пары origin, dest для авиаперевозчика с кодом “AA”? ans &lt;- flights[carrier == &quot;AA&quot;, .N, by=.(origin,dest)] head(ans) # origin dest N # 1: JFK LAX 3387 # 2: LGA PBI 245 # 3: EWR LAX 62 # 4: JFK MIA 1876 # 5: JFK SEA 298 # 6: EWR MIA 848 ## or equivalently using a character vector in &#39;by&#39; # ans &lt;- flights[carrier == &quot;AA&quot;, .N, by=c(&quot;origin&quot;, &quot;dest&quot;)] by принимает несколько столбцов. Мы просто предоставляем все столбцы, по которым проводится группировка. 1.5.1.4 - Как мы можем получить среднюю задержку прибытия и отлета для каждой пары origin, dest в каждом месяце для для авиаперевозчика с кодом “AA”? ans &lt;- flights[carrier == &quot;AA&quot;, .(mean(arr_delay), mean(dep_delay)), by=.(origin, dest, month)] ans # origin dest month V1 V2 # 1: JFK LAX 1 6.590361 14.2289157 # 2: LGA PBI 1 -7.758621 0.3103448 # 3: EWR LAX 1 1.366667 7.5000000 # 4: JFK MIA 1 15.720670 18.7430168 # 5: JFK SEA 1 14.357143 30.7500000 # --- # 196: LGA MIA 10 -6.251799 -1.4208633 # 197: JFK MIA 10 -1.880184 6.6774194 # 198: EWR PHX 10 -3.032258 -4.2903226 # 199: JFK MCO 10 -10.048387 -1.6129032 # 200: JFK DCA 10 16.483871 15.5161290 Мы не задали имена столбцов в выражении j, они были созданы автоматически (V1, V2). И снова, обратите внимание, исходный порядок группирующих столбцов сохраняется в результате. А что, если мы хотели упорядочить результат по этим группирующим столбцам: origin, dest и month? 1.5.2 b) keyby Сохранение в data.table исходного порядка групп является преднамеренным. Есть случаи, когда сохранение оригинального порядка имеет важное значение. Но порой мы хотели бы, чтобы происходило автоматическое упорядочивание по группирующим переменным. 1.5.2.1 - Так как же мы можем непосредственно упорядочить по всем группирующим переменным? ans &lt;- flights[carrier == &quot;AA&quot;, .(mean(arr_delay), mean(dep_delay)), keyby=.(origin, dest, month)] ans # origin dest month V1 V2 # 1: EWR DFW 1 6.427673 10.0125786 # 2: EWR DFW 2 10.536765 11.3455882 # 3: EWR DFW 3 12.865031 8.0797546 # 4: EWR DFW 4 17.792683 12.9207317 # 5: EWR DFW 5 18.487805 18.6829268 # --- # 196: LGA PBI 1 -7.758621 0.3103448 # 197: LGA PBI 2 -7.865385 2.4038462 # 198: LGA PBI 3 -5.754098 3.0327869 # 199: LGA PBI 4 -13.966667 -4.7333333 # 200: LGA PBI 5 -10.357143 -6.8571429 Все, что мы сделали, это заменили by на keyby. Это автоматически упорядочило результаты по группирующим переменным в порядке возрастания. Обратите внимание, что keyby() применяется после выполнения операции, т.е. для рассчитанного результата. Ключи: На самом деле keyby делает несколько больше, чем просто выполняет упорядочивание. Эта функция также задает ключ после упорядочивания путем установки атрибута под названием sorted. Но мы узнаем больше о ключах keys в следующей виньетке. В настоящий момент вы знаете, как использовать keyby для автоматического упорядочивания столбцов, заданных в by. 1.5.3 c) Цепочки Давайте вновь рассмотрим задачу получения количество рейсов для каждой пары origin, dest для авиаперевозчика с кодом “AA”. ans &lt;- flights[carrier == &quot;AA&quot;, .N, by = .(origin, dest)] 1.5.3.1 - Как мы можем упорядочить ans, используя столбец origin в порядке по возрастанию и столбец dest в порядке по убыванию? Мы можем хранить промежуточный результат в переменной, а затем использовать order(origin, -dest) для этой переменной. Это кажется довольно простым. ans &lt;- ans[order(origin, -dest)] head(ans) # origin dest N # 1: EWR PHX 121 # 2: EWR MIA 848 # 3: EWR LAX 62 # 4: EWR DFW 1618 # 5: JFK STT 229 # 6: JFK SJU 690 Напомним, что мы можем использовать “-” перед названием столбца внутри order() в таблице data.table. Это возможно благодаря внутренней оптимизации запросов data.table. Также напомним, что order(...) в таблице data.table автоматически оптимизирована для использования быстрого внутреннего способа упорядочивания forder(). Таким образом, вы можете продолжать использовать уже знакомые базовые функции R без ущерба для скорости или эффективности использования памяти, предлагаемых data.table. Мы рассмотрим этот вопрос более подробно в виньетке “data.table internals”. Но в данном случае приходится присваивать промежуточный результат, а затем его перезаписывать. Мы можем сделать лучше и избежать этого промежуточного присваивания переменной при помощи цепочечных выражений (chaining) . ans &lt;- flights[carrier == &quot;AA&quot;, .N, by=.(origin, dest)][order(origin, -dest)] head(ans, 10) # origin dest N # 1: EWR PHX 121 # 2: EWR MIA 848 # 3: EWR LAX 62 # 4: EWR DFW 1618 # 5: JFK STT 229 # 6: JFK SJU 690 # 7: JFK SFO 1312 # 8: JFK SEA 298 # 9: JFK SAN 299 # 10: JFK ORD 432 Мы можем прикреплять выражения одно за другим, формируя цепочку операций, т.е. DT[ ... ][ ... ][ ... ]. Или же мы можем объединять их в цепочки вертикально: DT[ ... ][ ... ][ ... ] 1.5.4 d) Выражения в by 1.5.4.1 - Может ли by также принимать выражения, или только столбцы? Да, может. Например, если мы хотим найти, сколько рейсов вылетели с опозданием, но прибыли заранее (или вовремя), или вылетели и прибыли с опозданием, и т.д… ans &lt;- flights[, .N, .(dep_delay&gt;0, arr_delay&gt;0)] ans # dep_delay arr_delay N # 1: TRUE TRUE 72836 # 2: FALSE TRUE 34583 # 3: FALSE FALSE 119304 # 4: TRUE FALSE 26593 Последняя строка соответствует dep_delay &gt; 0 = TRUE и arr_delay &gt; 0 = FALSE. мы можем видеть, что 26593 рейсов начались с опозданием, но прибыли заранее (или вовремя). Обратите внимание, что мы не задали никаких имен для by-выражения. И имена были автоматически присвоены в результате. Вы можете задать другие столбцы вместе с выражениями, например: DT[, .N, by=.(a, b&gt;0)]. 1.5.5 e) Множество столбцов в j - .SD 1.5.5.1 - Можем ли мы вычислить mean() отдельно для каждого столбца? Конечно, нецелесообразно вводить mean(myCol) для каждого столбца. Что, если mean() нужно рассчитать для 100 столбцов? Как мы можем сделать это эффективно? Чтобы понять, вспомните совет - “Поскольку j-выражение возвращает список, каждый элемент списка будет сконвертирован в столбец итоговой таблицы data.table”. Предположим, что мы можем обратиться к поднабору данных для каждой группы как к переменной при группировке, затем мы можем обработать в цикле все столбцы этой переменной, используя уже знакомую базовую функцию lapply(). Нам не нужно изучать никаких новых функций. 1.5.5.2 Специальный символ .SD: data.table предоставляет специальный символ под названием .SD. Он обозначает поднабор данных (Subset of Data) и сам по себе является таблицей data.table, содержащей данные для текущей группы, определенной с использованием by. Напомним, что data.table представляет собой список со столбцами равной длины. Давайте используем таблицу data.table DT, чтобы получить представление о том, как выглядит .SD. DT # ID a b c # 1: b 1 7 13 # 2: b 2 8 14 # 3: b 3 9 15 # 4: a 4 10 16 # 5: a 5 11 17 # 6: c 6 12 18 DT[, print(.SD), by=ID] # a b c # 1: 1 7 13 # 2: 2 8 14 # 3: 3 9 15 # a b c # 1: 4 10 16 # 2: 5 11 17 # a b c # 1: 6 12 18 # Empty data.table (0 rows) of 1 col: ID .SD по умолчанию содержит все столбцы, кроме того, по которому выполнена группировка. Создается с сохранением исходного порядка - данные, соответствующие ID = &quot;b&quot;, затем ID = &quot;a&quot;, а затем ID = &quot;c&quot;. Для расчетов по множеству столбцов мы может просто использовать базовую функцию lapply(). DT[, lapply(.SD, mean), by=ID] # ID a b c # 1: b 2.0 8.0 14.0 # 2: a 4.5 10.5 16.5 # 3: c 6.0 12.0 18.0 .SD содержит строки, соответствующие столбцам a, b и c для этой группы. Мы рассчитываем mean() для каждого из этих столбцов, используя уже знакомую базовую функцию lapply(). Каждая группа возвращается список из трех элементов, содержащих средние значения, которые становятся столбцами итоговой таблицы data.table. Поскольку функция lapply() возвращает список, нет необходимости дополнительно заключать ее в .(). Мы почти справились. Осталось рассмотреть одну маленькую деталь. В нашей таблице data.table flights мы хотим рассчитать mean() только для двух столбцов - arr_delay и dep_delay. Но .SD по умолчанию содержит все столбцы, кроме группирующих переменных. 1.5.5.3 - Как мы можем указать только те столбцы, для которых хотим рассчитать mean()? 1.5.5.4 .SDcols Использование аргумента .SDcols. Он принимает имена или индексы столбцов. Например, .SDcols = c(&quot;arr_delay&quot;, &quot;dep_delay&quot;) гарантирует, что .SD содержит только эти два столбца для каждой группы. Так же как в разделе про with = FALSE, вы можете указывать столбцы, которые нужно удалить, вместо столбцов, которые нужно оставить, при помощи - или !, а также выбирать идущие подряд столбцы как colA:colB или исключать их как !(colA:colB) или -(colA:colB). Теперь давайте попробуем использовать SD вместе с .SDcols, чтобы получить mean() для столбцов arr_delay и dep_delay, сгруппированных по origin, dest и month. flights[carrier == &quot;AA&quot;, ## Only on trips with carrier &quot;AA&quot; lapply(.SD, mean), ## compute the mean by=.(origin, dest, month), ## for every &#39;origin,dest,month&#39; .SDcols=c(&quot;arr_delay&quot;, &quot;dep_delay&quot;)] ## for just those specified in .SDcols # origin dest month arr_delay dep_delay # 1: JFK LAX 1 6.590361 14.2289157 # 2: LGA PBI 1 -7.758621 0.3103448 # 3: EWR LAX 1 1.366667 7.5000000 # 4: JFK MIA 1 15.720670 18.7430168 # 5: JFK SEA 1 14.357143 30.7500000 # --- # 196: LGA MIA 10 -6.251799 -1.4208633 # 197: JFK MIA 10 -1.880184 6.6774194 # 198: EWR PHX 10 -3.032258 -4.2903226 # 199: JFK MCO 10 -10.048387 -1.6129032 # 200: JFK DCA 10 16.483871 15.5161290 1.5.6 f) Поднабор .SD для каждой группы: 1.5.6.1 – Как мы можем вернуть первые две строки для каждого month? ans &lt;- flights[, head(.SD, 2), by=month] head(ans) # month year day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 1 2014 1 914 14 1238 13 0 AA N338AA 1 JFK # 2: 1 2014 1 1157 -3 1523 13 0 AA N335AA 3 JFK # 3: 2 2014 1 859 -1 1226 1 0 AA N783AA 1 JFK # 4: 2 2014 1 1155 -5 1528 3 0 AA N784AA 3 JFK # 5: 3 2014 1 849 -11 1306 36 0 AA N784AA 1 JFK # 6: 3 2014 1 1157 -3 1529 14 0 AA N787AA 3 JFK # dest air_time distance hour min # 1: LAX 359 2475 9 14 # 2: LAX 363 2475 11 57 # 3: LAX 358 2475 8 59 # 4: LAX 358 2475 11 55 # 5: LAX 375 2475 8 49 # 6: LAX 368 2475 11 57 .SD является таблицей data.table, содержащей все строки для данной группы. Мы просто выбираем первые две строки, как мы уже видели. head(.SD, 2) возвращается для каждой группы первые две строки как таблицу data.table, которая также является списком. Поэтому нам не нужно использовать .(). 1.5.7 g) Зачем делать j настолько гибким? Таким образом у нас есть единый синтаксис и возможность использования уже существующих (и знакомых) базовых функций вместо изучения новых. Для иллюстрации давайте использовать созданную в начале таблицу data.table DF. 1.5.7.1 – Как мы можем соединить столбцы a and b для каждой группы в ID? DT[, .(val = c(a,b)), by=ID] # ID val # 1: b 1 # 2: b 2 # 3: b 3 # 4: b 7 # 5: b 8 # 6: b 9 # 7: a 4 # 8: a 5 # 9: a 10 # 10: a 11 # 11: c 6 # 12: c 12 Вот и все. Не нужно никакого специального синтаксиса. Все, что нужно - это знание базовой функции c(), которая соединяет векторы, и совет про списки выше (j-выражение возвращает список). 1.5.7.2 - Что, если бы мы хотели получить все значения соединенных столбцов a и b, но в виде столбца-списка? DT[, .(val = list(c(a,b))), by=ID] # ID val # 1: b 1,2,3,7,8,9 # 2: a 4, 5,10,11 # 3: c 6,12 Тут мы сперва соединили значения при помощи c(a,b) для каждой группы и обернули их вызовом list(). Таким образом, для каждой группы мы верули список из всех соединенных значений. Заметим, что запятые служат только для отображения. Столбец-список может содержать любой объект в каждой ячейке, и в этом примере каждая ячейка является вектором, и некоторые ячейки содержат более длинные векторы, чем другие. Как только вы начнете использовать j, вы поймете, насколько мощным может быть этот синтаксис. Очень полезный способ, чтобы понять это - поиграть с данными при помощи функции print(). Например: ## (1) look at the difference between DT[, print(c(a,b)), by=ID] # [1] 1 2 3 7 8 9 # [1] 4 5 10 11 # [1] 6 12 # Empty data.table (0 rows) of 1 col: ID ## (2) and DT[, print(list(c(a,b))), by=ID] # [[1]] # [1] 1 2 3 7 8 9 # # [[1]] # [1] 4 5 10 11 # # [[1]] # [1] 6 12 # Empty data.table (0 rows) of 1 col: ID В примере (1) для для каждой группы возвращается вектор с длиной = 6, 4, 2. Однако (2) возвращает список длиной 1 для каждой группы с первым элементом, содержащим векторы с длиной 6, 4, 2. Поэтому (1) в результате имеет длину 6+4+2=12, в то время как (2) возвращает 1+1+1=3. 1.6 Резюме Общая форма синтаксиса data.table: DT[i, j, by] 1.6.1 Использование i: мы можем выбирать строки, как в data.frame - за исключением того, что не нужно постоянно использовать DT$1, так как столбцы в data.table ведут себя так, как если бы они были переменными. Мы также можем упорядочивать data.table, используя функцию order(), которая использует для большей производительности быструю внутреннюю реализацию упорядочивания в data.table. Мы можем делать гораздо больше в i при помощи установки ключей в data.table, что позволяет выполнять молниеносные выборки поднаборов и объединения. Мы это увидим в виньетках “Keys and fast binary search based subsets” и “Joins and rolling joins”. 1.6.2 Использование j: Выбор столбцов в стиле data.table: DT[, .(colA, colB)]. Выбор столбцов в стиле data.frame: DT[, c(&quot;colA&quot;, &quot;colB&quot;), with=FALSE]. Вычисления на основе столбцов: DT[, .(sum(colA), mean(colB))]. Указание имен, если нужно: DT[, .(sA =sum(colA), mB = mean(colB))]. Комбинация с i: DT[colA &gt; value, sum(colB)]. 1.6.3 Использование by: Используя by, мы можем осуществлять группировку по столбцам, указывая список столбцов или символьный вектор с именами столбцов, или даже используя выражения. Гибкость j в сочетании с by и i создает очень мощный синтаксис. by может обрабатывать множественные столбцы, а также выражения. Мы можем использовать keyby для группирующих столбцов с целью автоматического упорядочивания результатов группировки. Мы можем использовать .SD и .SDcols в j для обработки множественных столбцов с использованием уже знакомых базовых функций. Вот несколько примеров: DT[, lapply(.SD, fun), by=., .SDcols=...] - применяет fun ко всем столбцам, указанным в .SDcols, в то время как группировка по столбцам задана в by. DT[, head(.SD, 2), by=.] - возвращает первые две строки для каждой группы. DT[col &gt; val, head(.SD, 1), by=.] - комбинация i, j и by. 1.6.4 И запомните совет: Поскольку j-выражение возвращает список, каждый элемент списка станет столбцом итоговой таблицы data.table. В следующей виньетке мы увидим, как добавлять/обновлять/удалять столбцы по ссылке и как комбинировать это с i и by. P.S. Очень познавательные примеры на SO "],
["02_data.table_keys.html", "2 Ключи и создание поднаборов на основе быстрого бинарного поиска 2.1 Данные 2.2 Введение 2.3 1. Ключи 2.4 2. Комбинирование ключей с j и by 2.5 3. Дополнительные аргументы - mult и nomatch 2.6 4. Бинарный поиск в сравнении со сканированием вектора 2.7 Резюме", " 2 Ключи и создание поднаборов на основе быстрого бинарного поиска Эта виньетка предназначена для тех, кто уже знаком с синтаксисом data.table, его общим видом, тем, как выбирать строки в i, выбирать и вычислять столбцы, добавлять/изменять/удалять столбцы по ссылке в j и выполнять группировку при помощи by. Если вы не знакомы с этими концепциями, пожалуйста, прочтите сперва виньетки “Введение в data.table” и “Семантика ссылок”. 2.1 Данные Мы будем использовать набор данных flights, так же как в виньетке “Введение в data.table”. flights &lt;- fread(&quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/flights/NYCflights14/flights14.csv&quot;) head(flights) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 JFK # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 JFK # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 JFK # 4: 2014 1 1 722 -8 1014 -26 0 AA N3EHAA 29 LGA # 5: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 JFK # 6: 2014 1 1 1824 4 2145 0 0 AA N3DEAA 119 EWR # dest air_time distance hour min # 1: LAX 359 2475 9 14 # 2: LAX 363 2475 11 57 # 3: LAX 351 2475 19 2 # 4: PBI 157 1035 7 22 # 5: LAX 350 2475 13 47 # 6: LAX 339 2454 18 24 dim(flights) # [1] 253316 17 2.2 Введение В этой виньетке мы: сперва введем понятие ключа key в таблице data.table, а также зададим и используем ключи для создания поднаборов в i на основе быстрого бинарного поиска увидим, как можно комбинировать создание поднаборов на основе ключей с j и by тем же способом, что и раньше взглянем на другие полезные аргументы - mult и nomatch и, в заключение, оценим преимущество использования ключей - выполним создание поднаборов на основе быстрого бинарного поиска и сравним с традиционным подходом, который состоит в сканировании вектора. 2.3 1. Ключи 2.3.1 a) Что такое ключ? В виньетке “Введение в data.table” мы видели, как выбирать поднаборы строк в i при помощи логических выражений, номеров строк и с использованием order(). В этом разделе мы рассмотрим другой способ невероятно быстрого создания поднаборов - при помощи ключей. Давайте сперва взглянем на таблицы data.frames. Все они имеют атрибут имен строк. Рассмотрим data.frame DF ниже. set.seed(1L) DF = data.frame(ID1 = sample(letters[1:2], 10, TRUE), ID2 = sample(1:3, 10, TRUE), val = sample(10), stringsAsFactors = FALSE, row.names = sample(LETTERS[1:10])) DF # ID1 ID2 val # C a 3 5 # D a 1 6 # E b 2 4 # G a 1 2 # B b 1 10 # H a 2 8 # I b 1 9 # F b 2 1 # J a 3 7 # A b 2 3 rownames(DF) # [1] &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;G&quot; &quot;B&quot; &quot;H&quot; &quot;I&quot; &quot;F&quot; &quot;J&quot; &quot;A&quot; Мы можем выбрать отдельную строку, используя ее имя, как показано ниже: DF[&quot;C&quot;, ] # ID1 ID2 val # C a 3 5 Т.е. имена строк представляют собой (более или менее) индексы строк в таблице data.frame. Однако, Каждая строка ограничена ровно одним именем. Но, например, человек имеет имя и фамилию. Телефонный справочник удобно организовать сначала по фамилии, затем по имени. Кроме того, имена строк должны быть уникальными. rownames(DF) = sample(LETTERS[1:5], 10, TRUE) # Warning: non-unique values when setting &#39;row.names&#39;: &#39;C&#39;, &#39;D&#39; # Error in `row.names&lt;-.data.frame`(`*tmp*`, value = value): duplicate &#39;row.names&#39; are not allowed Теперь давайте сконвертируем эту таблицу в data.table. DT = as.data.table(DF) DT # ID1 ID2 val # 1: a 3 5 # 2: a 1 6 # 3: b 2 4 # 4: a 1 2 # 5: b 1 10 # 6: a 2 8 # 7: b 1 9 # 8: b 2 1 # 9: a 3 7 # 10: b 2 3 rownames(DT) # [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; Обратите внимание, что имена строк были удалены. data.tables никогда не используют имена строк. Так как data.tables наследуют data.frames, они по-прежнему имеют атрибут имен строк, но никогда его не используют. Вскоре мы увидим, почему. Если вы хотите сохранить имена строк, используйте keep.rownames = TRUE в as.data.table() - это создаст новый столбец rn и присвоит ему имена строк. Вместо этого, в data.tables мы задаем и используем ключи keys. Думайте о них как о “заряженных” именах строк. 2.3.1.1 Ключи и их свойства Мы можем устанавливать ключи для множественных столбцов, которые могут иметь разные типы - integer, numeric, character, factor, integer64 и т.д. Списки и комплексные числа пока не поддерживаются. Уникальность не обеспечивается, т.е. допускаются повторяющиеся значения ключа. Поскольку строки отсортированы по ключу, любые дубликаты в ключевых столбцах отображаются последовательно. Установка ключа key делает две вещи: переупорядочивает строки в таблице data.table по столбцам, предоставленным по ссылке, всегда в порядке по возрастанию. отмечает эти столбцы в качестве ключевых столбцов путем установки атрибута sorted таблицы data.table. Поскольку строки переупорядочены, таблица data.table может иметь не более одного ключа, поскольку она не может быть отсортирована более чем одним способом [одновременно]. Далее в этой виньетке мы будем работать с набором данных flights. 2.3.2 b) Установка, получение и использование ключей в таблице data.table 2.3.2.1 - Как мы можем установить столбец origin в качестве ключа в таблице data.table flights? setkey(flights, origin) head(flights) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 1824 4 2145 0 0 AA N3DEAA 119 EWR # 2: 2014 1 1 1655 -5 2003 -17 0 AA N5CFAA 172 EWR # 3: 2014 1 1 1611 191 1910 185 0 AA N471AA 300 EWR # 4: 2014 1 1 1449 -1 1753 -2 0 AA N4WNAA 320 EWR # 5: 2014 1 1 607 -3 905 -10 0 AA N5DMAA 1205 EWR # 6: 2014 1 1 949 4 1243 -17 0 AA N491AA 1223 EWR # dest air_time distance hour min # 1: LAX 339 2454 18 24 # 2: MIA 161 1085 16 55 # 3: DFW 214 1372 16 11 # 4: DFW 214 1372 14 49 # 5: MIA 154 1085 6 7 # 6: DFW 215 1372 9 49 ## alternatively we can provide character vectors to the function &#39;setkeyv()&#39; # setkeyv(flights, &quot;origin&quot;) # useful to program with Мы можем использовать функцию setkey() и передавать имена столбцов (без кавычек). Это полезно при интерактивном использовании. В качестве альтернативы, вы можете передавать символьный вектор имен строк функции setkeyv(). Это особенно полезно при проектировании функций для передачи столбцов для установки ключей в качестве аргументов. Обратите внимание, что мы не должны присваивать результаты переменной. Так происходит, потому что setkey() и setkeyv() изменяют исходную таблицу data.table по ссылке подобно :=, как мы видели в виньетке “Введение в data.table”. Результат возвращается скрыто. Таблица data.table теперь переупорядочена (или отсортирована) по указанному столбцу - origin. Поскольку мы переупорядочивали по ссылке, требуется лишь дополнительный объем памяти для столбца, длина которого равна количеству строк в data.table; это опеспечивает эффективность использования памяти. Вы также можете задавать ключи непосредственно при создании таблицы data.table при помощи функции data.table(), используя аргумент key=. Он принимает символьный вектор имен столбцов. 2.3.2.2 set* и :=: В data.table только оператор := и все функции вида set* (например, setkey, setorder, setnames и т.д.) изменяют исходный объект по ссылке. Как только вы задали определенные ключевые столбцы в таблице data.table, вы можете выбирать поднаборы при помощи запросов по этим ключевым столбцам с использованием .() в i. Напомним, что .() является псевдонимом для list(). 2.3.2.3 - Использование ключевого столбца origin для выбора всех строк, для которых аэропортом отправки является “JFK” flights[.(&quot;JFK&quot;)] # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 JFK # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 JFK # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 JFK # 4: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 JFK # 5: 2014 1 1 2133 -2 37 -18 0 AA N323AA 185 JFK # --- # 81479: 2014 10 31 1705 -4 2024 -21 0 UA N596UA 512 JFK # 81480: 2014 10 31 1827 -2 2133 -37 0 UA N568UA 514 JFK # 81481: 2014 10 31 1753 0 2039 -33 0 UA N518UA 535 JFK # 81482: 2014 10 31 924 -6 1228 -38 0 UA N512UA 541 JFK # 81483: 2014 10 31 1124 -6 1408 -38 0 UA N590UA 703 JFK # dest air_time distance hour min # 1: LAX 359 2475 9 14 # 2: LAX 363 2475 11 57 # 3: LAX 351 2475 19 2 # 4: LAX 350 2475 13 47 # 5: LAX 338 2475 21 33 # --- # 81479: SFO 337 2586 17 5 # 81480: SFO 344 2586 18 27 # 81481: LAX 320 2475 17 53 # 81482: SFO 343 2586 9 24 # 81483: LAX 323 2475 11 24 ## alternatively # flights[J(&quot;JFK&quot;)] (or) flights[list(&quot;JFK&quot;)] ключевым столбцом уже был задан столбец origin, поэтому достаточно напрямую передать значение, в данном случае “JFK”. Синтаксис .() помогает определить, что задача требует поиска значения “JFK” в ключевом столбце таблицы data.table (в данном случае это столбец origin) Сперва получены индексы строк, соответствующих значению “JFK” в origin. И, поскольку в j нет никакого выражения, возвращены все столбцы для этих индексов строк. Для отдельного ключевого столбца символьного типа вы можете опустить .() и использовать значения непосредственно, подобно созданию поднабора в data.frames с использованием имен строк. flights[&quot;JFK&quot;] ## same as flights[.(&quot;JFK&quot;)] Мы можем выбрать любой поднабор значений в соответствии с требованиями. flights[c(&quot;JFK&quot;, &quot;LGA&quot;)] ## same as flights[.(c(&quot;JFK&quot;, &quot;LGA&quot;))] Это выражение вернет все столбцы со строками, соответствующими значениям “JFK” или “LGA” для столбца origin. 2.3.2.4 - Как мы можем получить ключевые столбцы таблицы data.table? Используем функцию key(). key(flights) # [1] &quot;origin&quot; Функция возвращает символьный вектор со всеми ключевыми столбцами Если ключи не заданы, возвращается NULL. 2.3.3 c) Ключи и множественные столбцы Напомним, что ключи - это как заряженные имена строк. Мы можем задавать ключи для множественных столбцов разных типов. 2.3.3.1 - Как я могу задать ключи для столбцов origin и dest? setkey(flights, origin, dest) head(flights) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 2 724 -2 810 -25 0 EV N11547 4373 EWR # 2: 2014 1 3 2313 88 9 79 0 EV N18120 4470 EWR # 3: 2014 1 4 1526 220 1618 211 0 EV N11184 4373 EWR # 4: 2014 1 4 755 35 848 19 0 EV N14905 4551 EWR # 5: 2014 1 5 817 47 921 42 0 EV N19966 4470 EWR # 6: 2014 1 5 2301 66 2 62 0 EV N19966 4682 EWR # dest air_time distance hour min # 1: ALB 30 143 7 24 # 2: ALB 29 143 23 13 # 3: ALB 32 143 15 26 # 4: ALB 32 143 7 55 # 5: ALB 26 143 8 17 # 6: ALB 31 143 23 1 ## or alternatively # setkeyv(flights, c(&quot;origin&quot;, &quot;dest&quot;)) # provide a character vector of column names key(flights) # [1] &quot;origin&quot; &quot;dest&quot; Таблица data.table сортируется сначала по origin, а затем по dest по ссылке. 2.3.3.2 - Выбрать все строки, для которых первый ключевой столбец имеет значение “JFK”, а второй - “MIA” flights[.(&quot;JFK&quot;, &quot;MIA&quot;)] # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 1509 -1 1828 -17 0 AA N5FJAA 145 JFK # 2: 2014 1 1 917 7 1227 -8 0 AA N5DWAA 1085 JFK # 3: 2014 1 1 1227 2 1534 -1 0 AA N635AA 1697 JFK # 4: 2014 1 1 546 6 853 3 0 AA N5CGAA 2243 JFK # 5: 2014 1 1 1736 6 2043 -12 0 AA N397AA 2351 JFK # --- # 2746: 2014 10 31 1659 -1 1956 -22 0 AA N5FNAA 2351 JFK # 2747: 2014 10 31 826 -3 1116 -20 0 AA N5EYAA 1085 JFK # 2748: 2014 10 31 647 2 941 -17 0 AA N5BTAA 1101 JFK # 2749: 2014 10 31 542 -3 834 -12 0 AA N3ETAA 2299 JFK # 2750: 2014 10 31 1944 29 2232 4 0 AA N5FSAA 2387 JFK # dest air_time distance hour min # 1: MIA 161 1089 15 9 # 2: MIA 166 1089 9 17 # 3: MIA 164 1089 12 27 # 4: MIA 157 1089 5 46 # 5: MIA 154 1089 17 36 # --- # 2746: MIA 148 1089 16 59 # 2747: MIA 146 1089 8 26 # 2748: MIA 150 1089 6 47 # 2749: MIA 150 1089 5 42 # 2750: MIA 146 1089 19 44 2.3.3.3 Как здесь работает создание поднабора? Важно понимать, как это работает изнутри. “JFK” сначала сопоставляется с первым ключевым столбцом origin. И среди этих сопоставленных строк “MIA” сопоставляется со вторым ключевым столбцом dest для получения индексов строк, где origin и dest совпадают с данными значениями. Поскольку элемент j не задан, мы просто возвращаем все столбцы для этих индексов строк. 2.3.3.4 - Выбрать все строки, для которых только первый ключевой столбец origin соответствует значению “JFK” key(flights) # [1] &quot;origin&quot; &quot;dest&quot; flights[.(&quot;JFK&quot;)] ## or in this case simply flights[&quot;JFK&quot;], for convenience # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 2011 10 2308 4 0 B6 N766JB 65 JFK # 2: 2014 1 2 2215 134 145 161 0 B6 N507JB 65 JFK # 3: 2014 1 7 2006 6 2314 6 0 B6 N652JB 65 JFK # 4: 2014 1 8 2009 15 2252 -15 0 B6 N613JB 65 JFK # 5: 2014 1 9 2039 45 2339 32 0 B6 N598JB 65 JFK # --- # 81479: 2014 10 31 800 0 1040 -18 0 DL N915AT 2165 JFK # 81480: 2014 10 31 1932 1 2228 -8 0 B6 N516JB 225 JFK # 81481: 2014 10 31 1443 -2 1726 -22 0 B6 N334JB 325 JFK # 81482: 2014 10 31 957 -8 1255 -5 0 B6 N637JB 925 JFK # 81483: 2014 10 31 831 -4 1118 -18 0 B6 N595JB 1025 JFK # dest air_time distance hour min # 1: ABQ 280 1826 20 11 # 2: ABQ 252 1826 22 15 # 3: ABQ 269 1826 20 6 # 4: ABQ 259 1826 20 9 # 5: ABQ 267 1826 20 39 # --- # 81479: TPA 142 1005 8 0 # 81480: TPA 149 1005 19 32 # 81481: TPA 145 1005 14 43 # 81482: TPA 149 1005 9 57 # 81483: TPA 145 1005 8 31 Поскольку мы не задали никаких значений для второго ключевого столбца dest, происходит лишь сопоставление “JFK” в первом ключевом столбце origin и возврат всех соответствующих строк. 2.3.3.5 - Выбрать все строки, для которых только второй ключевой столбец dest соответствует значению “MIA” flights[.(unique(origin), &quot;MIA&quot;)] # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 1655 -5 2003 -17 0 AA N5CFAA 172 EWR # 2: 2014 1 1 607 -3 905 -10 0 AA N5DMAA 1205 EWR # 3: 2014 1 1 1125 -5 1427 -8 0 AA N3AGAA 1623 EWR # 4: 2014 1 1 1533 43 1840 42 0 UA N491UA 244 EWR # 5: 2014 1 1 2130 60 29 49 0 UA N476UA 308 EWR # --- # 9924: 2014 10 31 1348 -11 1658 -8 0 AA N3AMAA 2283 LGA # 9925: 2014 10 31 950 -5 1257 -11 0 AA N3LFAA 2287 LGA # 9926: 2014 10 31 658 -2 1017 10 0 AA N3HNAA 2451 LGA # 9927: 2014 10 31 1913 -2 2212 -16 0 AA N3LFAA 2455 LGA # 9928: 2014 10 31 1530 1 1839 -11 0 US N768US 1715 LGA # dest air_time distance hour min # 1: MIA 161 1085 16 55 # 2: MIA 154 1085 6 7 # 3: MIA 157 1085 11 25 # 4: MIA 155 1085 15 33 # 5: MIA 162 1085 21 30 # --- # 9924: MIA 157 1096 13 48 # 9925: MIA 150 1096 9 50 # 9926: MIA 156 1096 6 58 # 9927: MIA 156 1096 19 13 # 9928: MIA 164 1096 15 30 2.3.3.6 Что здесь происходит? Прочтите еще раз пункт “Как здесь работает создание поднабора?”. Значение для второго ключевого столбца “MIA” должно найти соответствия в ключевом столбце dest среди строк, для которых есть соответствие по первому ключевому столбцу origin. Мы не можем пропустить значения предшествующих ключевых столбцов. Поэтому мы задаем все уникальные значения ключевого столбца origin. “MIA” автоматически повторяется, чтобы соответствовать длине unique(origin), которая равна 3. 2.4 2. Комбинирование ключей с j и by По сути, все, что мы видели до сих пор - это получение индексов строк в i, но с использованием другого метода - с помощью ключей. Не удивительно, что мы можем делать то же самое в j и by, как мы видели в предыдущих виньетках. Мы покажем это на нескольких примерах. 2.4.1 a) Выбор в j 2.4.1.1 Вернуть столбец arr_delay как таблицу data.table, соответствующую origin = &quot;LGA&quot; и dest = &quot;TPA&quot;. key(flights) # [1] &quot;origin&quot; &quot;dest&quot; flights[.(&quot;LGA&quot;, &quot;TPA&quot;), .(arr_delay)] # arr_delay # 1: 1 # 2: 14 # 3: -17 # 4: -4 # 5: -12 # --- # 1848: 39 # 1849: -24 # 1850: -12 # 1851: 21 # 1852: -11 Индексы строк, соответствующих origin = &quot;LGA&quot; и dest = &quot;TPA&quot;, получены с использованием поднабора на основе ключей. Как только у нас есть индексы строк, мы смотрим на j, где требуется только столбец arr_delay. Поэтому мы просто выбираем столбец arr_delay для этих индексов строк точно таким же образом, как мы видели в виньетке “Введение в data.table”. Мы могли бы также получить результат с помощью with = FALSE. flights[.(&quot;LGA&quot;, &quot;TPA&quot;), &quot;arr_delay&quot;, with=FALSE] 2.4.2 b) Цепочки операций 2.4.2.0.1 - Для результатов, полученных выше, использовать цепочку операций для сортировки столбца по убыванию. flights[.(&quot;LGA&quot;, &quot;TPA&quot;), .(arr_delay)][order(-arr_delay)] # arr_delay # 1: 486 # 2: 380 # 3: 351 # 4: 318 # 5: 300 # --- # 1848: -40 # 1849: -43 # 1850: -46 # 1851: -48 # 1852: -49 2.4.3 c) Вычислить или выполнить в j 2.4.3.1 - Найти максимальную задержку прибытия, соответствующую origin = &quot;LGA&quot; и dest = &quot;TPA&quot;. flights[.(&quot;LGA&quot;, &quot;TPA&quot;), max(arr_delay)] # [1] 486 Мы можем убедиться, что результат совпадает с первым значением (486) из предыдущего примера. 2.4.4 d) Частичное присваивание по ссылке с использованием := в j Мы уже видели этот пример в виньетке “Семантика ссылок”. Давайте взглянем на все часы hours, доступные в таблице data.table flights: # get all &#39;hours&#39; in flights flights[, sort(unique(hour))] # [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Мы видим, что данные имеют всего 25 уникальных значений. Присутствуют и 0, и 24. Давайте двигаться дальше и заменим 24 на 0, но в этот раз с использованием ключа. setkey(flights, hour) key(flights) # [1] &quot;hour&quot; flights[.(24), hour := 0L] key(flights) # NULL Сперва мы сделали столбец hour ключом key . Это переупорядочило flights по столбцу hour и пометило этот столбец как key. Теперь мы можем создавать поднаборы по столбцу hour, используя .(). Мы выбрали значение 24 и получили соответствующие индексы строк. И для этих индексов мы заменили столбец key значением 0. После того, как мы заменили значения ключевого столбца, таблица data.table flights больше не является упорядоченной по столбцу hour. Таким образом, ключ был автоматически удален путем установки в NULL. Теперь значений 24 не должно быть в столбце hour. flights[, sort(unique(hour))] # [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 2.4.5 e) Агрегирование с использованием by Давайте снова сделаем ключом столбцы origin, dest. setkey(flights, origin, dest) key(flights) # [1] &quot;origin&quot; &quot;dest&quot; 2.4.5.1 - Получить максимальную задержку вылета за каждый месяц для origin = &quot;JFK&quot;. Упорядочить результат по month ans &lt;- flights[&quot;JFK&quot;, max(dep_delay), keyby=month] head(ans) # month V1 # 1: 1 881 # 2: 2 1014 # 3: 3 920 # 4: 4 1241 # 5: 5 853 # 6: 6 798 key(ans) # [1] &quot;month&quot; Мы выбираем поднабор по ключевому столбцу origin для получения индексов строк, соответствующих “JFK”. После того, как мы получили индексы строк, нам нужно лишь два столбца - month, чтобы выполнить по нему группировку, и dep_delay для получения max() в каждой группе. Поэтому оптимизация запросов в data.table приведет к выбору только этих двух столбцов для соответствующих индексов строк, полученных в i, для скорости и эффективного использования памяти. И на этом поднаборе мы выполняем группировку по month и рассчитываем max(dep_delay). Мы используем keyby, чтобы автоматически сделать month ключом для результата. Теперь мы понимаем, что это значит. В добавок к упорядочиванию, это также делает month ключевым столбцом. 2.5 3. Дополнительные аргументы - mult и nomatch 2.5.1 a) Аргумент mult Для каждого запроса при помощи аргумента mult мы можем выбрать, должны ли быть возвращены “все” соответствующие строки, или только “первая” или “последняя”. Значение по умолчанию “все” - это то, что мы видели до сих пор. 2.5.1.1 - Выбрать только первую строку из всех строк, для которых origin соответствует “JFK” и dest соответствует “MIA” flights[.(&quot;JFK&quot;, &quot;MIA&quot;), mult=&quot;first&quot;] # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 546 6 853 3 0 AA N5CGAA 2243 JFK # dest air_time distance hour min # 1: MIA 157 1089 5 46 2.5.1.2 - Выбрать только последнюю строку из всех строк, для которых origin соответствует “LGA”, “JFK”, “EWR” и dest соответствует “XNA” flights[.(c(&quot;LGA&quot;, &quot;JFK&quot;, &quot;EWR&quot;), &quot;XNA&quot;), mult=&quot;last&quot;] # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 5 23 1803 163 2003 148 0 MQ N515MQ 3553 LGA # 2: NA NA NA NA NA NA NA NA NA NA NA JFK # 3: 2014 2 3 1208 231 1516 268 0 EV N14148 4419 EWR # dest air_time distance hour min # 1: XNA 158 1147 18 3 # 2: XNA NA NA NA NA # 3: XNA 184 1131 12 8 Запрос “JFK”, “XNA” не соответствует никаким строкам в таблице flights, поэтому возвращается NA. И снова, запрос для второго ключевого столбца dest, “XNA”, повторяется, чтобы соответствовать длине первого ключевого столбца origin, которая равна 3. 2.5.2 b) Аргумент nomatch Мы можем выбрать при помощи аргумента nomatch, должны ли запросы, для которых нет соответствий, возвращать NA или вообще быть пропущенными. 2.5.2.1 - Выбрать только те строки из предыдущего примера, для которых есть соответствия lights[.(c(&quot;LGA&quot;, &quot;JFK&quot;, &quot;EWR&quot;), &quot;XNA&quot;), mult=&quot;last&quot;, nomatch = 0L] # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 5 23 1803 163 2003 148 0 MQ N515MQ 3553 LGA # 2: 2014 2 3 1208 231 1516 268 0 EV N14148 4419 EWR # dest air_time distance hour min # 1: XNA 158 1147 18 3 # 2: XNA 184 1131 12 8 Значением по умолчанию для nomatch является NA. Установка nomatch = 0L приведет к пропуску запросов, для которых нет соответствий. Для запроса “JFK”, “XNA” нет соответствующих строк в таблице flights, поэтому он пропускается. 2.6 4. Бинарный поиск в сравнении со сканированием вектора До сих пор мы видели, как можно устанавливать и использовать ключи для создания поднаборов. Но в чем преимущество? Например, вместо: # key by origin,dest columns flights[.(&quot;JFK&quot;, &quot;MIA&quot;)] мы можем выполнить: flights[origin == &quot;JFK&quot; &amp; dest == &quot;MIA&quot;] Одним из преимуществ, вероятно, является меньшее количество кода. Но, более того, создание поднаборов на основе бинарного поиска является невероятно быстрым. 2.6.1 a) Производительность бинарного поиска В качестве примера, давайте создадим таблицу data.table с 20 млн. строк и тремя столбцами, задав столбцы x и y в качестве ключа. set.seed(2L) N = 2e7L DT = data.table(x = sample(letters, N, TRUE), y = sample(1000L, N, TRUE), val=runif(N), key = c(&quot;x&quot;, &quot;y&quot;)) print(object.size(DT), units=&quot;Mb&quot;) # 381.5 Mb key(DT) # [1] &quot;x&quot; &quot;y&quot; DT весит ~380MB. Это не так уж много, но достаточно для иллюстрации. Как мы видели в виньетке “Введение в data.table”, мы можем выбрать те строки, где x = &quot;g&quot; и y = 877, следующим образом: ## (1) Usual way of subsetting - vector scan approach t1 &lt;- system.time(ans1 &lt;- DT[x == &quot;g&quot; &amp; y == 877L]) t1 # user system elapsed # 0.871 0.022 0.919 head(ans1) # x y val # 1: g 877 0.3946652 # 2: g 877 0.9424275 # 3: g 877 0.7068512 # 4: g 877 0.6959935 # 5: g 877 0.9673482 # 6: g 877 0.4842585 dim(ans1) # [1] 761 3 Теперь давайте попробуем выбрать поднабор с использованием ключей. ## (2) Subsetting using keys t2 &lt;- system.time(ans2 &lt;- DT[.(&quot;g&quot;, 877L)]) t2 # user system elapsed # 0.001 0.000 0.002 head(ans2) # x y val # 1: g 877 0.3946652 # 2: g 877 0.9424275 # 3: g 877 0.7068512 # 4: g 877 0.6959935 # 5: g 877 0.9673482 # 6: g 877 0.4842585 dim(ans2) # [1] 761 3 identical(ans1$val, ans2$val) # [1] TRUE Произошло ускорение в ~460 раз! 2.6.2 b) Почему использование ключей в data.table приводит к молниеносному созданию поднаборов? Чтобы это понять, давайте сперва рассмотрим подход, состоящий в сканировании вектора (метод 1). 2.6.2.1 Сканирование вектора: Происходит поиск значения “g” по столбцу x строка за строкой по всем 20 млн. строк. Это приводит к созданию логического вектора длиной 20 млн. со значениями TRUE, FALSE или NA, которые соответствуют значениям x. Аналогичным образом, по столбцу y ищутся значения 877 среди всех 20 млн. строк и сохраняются в другом логическом векторе. Поэлементная операция &amp; выполняется на промежуточных логических векторах, и возвращаются все строки, для которых значение выражения равно TRUE. Это то, что мы называем сканированием вектора. И это весьма неэффективно, особенно в случае больших таблиц, а также когда требуется повторное создание поднаборов, потому что каждый раз происходит повторное сканирование всех строк. Теперь давайте рассмотрим бинарный поиск (метод 2). Напомним, из раздела “Свойства ключей”, что установка ключей переупорядочивает таблицу data.table по ключевым столбцам. Поскольку данные отсортированы, нам не нужно осуществлять сканирование по всей длине столбца! Вместо этого мы можем использовать бинарный поиск значения за время O(log n), в отличие от времени O(n) в случае сканирования вектора, где n является числом строк в таблице data.table 2.6.2.2 Бинарный поиск: Вот очень простой пример. Рассмотрим (упорядоченные) значения, показанные ниже: 1, 5, 10, 19, 22, 23, 30 Предположим, мы хотели бы найти позицию, соответствующую значению 1, используя бинарный поиск - потому что мы знаем, что данные отсортированы. Начинаем со значения в середине = 19. 1 == 19? Нет. 1 &lt; 19. Поскольку значение, которое мы ищем, меньше 19, оно должно быть где-то до 19. Таким образом, мы можем отбросить другую половину, которая &gt;= 19. Наш набор значений теперь сократился до 1, 5, 10. Еще раз возьмем значение в середине = 5. 1 == 5? Нет. 1 &lt; 5. Наш набор значений сократился до 1. 1 == 1? Да. Соответствующий индекс также равен 1. И это единственное соответствие. С другой стороны, сканирование вектора привело бы к проверке всех значений, количество которых 7. Видно, что с каждым поиском мы уменьшаем количество элементов в два раза. Поэтому выбор поднаборов на основе бинарного поиска является невероятно быстрым. Поскольку строки каждого столбца data.tables находятся в смежных ячейках памяти, операции выполняются способом, эффективным с точки зрения использования кэша (что также способствует большей скорости). Кроме того, поскольку мы получаем индексы соответствующих строк непосредственно, без создания этих больших логических векторов (равных по размеру числу строк в таблице data.table), также более эффективно используется память. 2.7 Резюме В этой виньетке мы изучили другой способ выбора поднаборов строк в i путем установки ключей в таблице data.table. Установка ключей позволяет нам выполнять молниеносное создание поднаборов при помощи использования бинарного поиска. В частности, мы увидели, как: устанавливать ключ и создавать поднаборы в таблице data.table, используя ключ создавать поднаборы, используя ключи, которые задают индексы строк в i, но гораздо быстрее комбинировать создание поднаборов по ключу с j и by. Обратите внимание, что операции j и by - те же, что и раньше. Создание поднаборов на основе ключа является невероятно быстрым и особенно полезным, когда задача включает повторяющееся создание поднаборов. Вообще, мы не обязаны устанавливать и использовать ключи для операций агрегирования, пока наши данные не являются очень большими и/или задача не требует повторяющегося создания поднаборов, когда подход с использованием ключей будет заметно более производительным. Тем не менее, установка ключей имеет важное значение для объединения двух таблиц data.table, что является предметом обсуждения в виньетке “Joins and rolling joins” (еще не написанной - прим. пер.). Мы расширим концепцию создания поднаборов на основе ключей для объединения двух таблиц data.table, основанного на ключевых столбцах. "],
["03_data.table_reference.html", "3 Семантика ссылок 3.1 Данные 3.2 Введение 3.3 1. Семантика ссылок 3.4 2. Добавление/обновление/удаление столбцов по ссылке 3.5 3 := и copy() 3.6 Резюме", " 3 Семантика ссылок В этой виньетке обсуждается семантика ссылок в data.table, которая позволяет добавлять/обновлять/удалять столбцы в data.table по ссылке, а также комбинирование с i и by. Она предназначена для тех, кто уже знаком с синтаксисом data.table, его общим видом, способом выбора строк в i, выбором и вычислением столбцов, выполнением агрегирования по группам. Если вы не знакомы с этими концепциями, пожалуйста, прочтите сперва виньетку “Введение в data.table”. 3.1 Данные Мы будем использовать набор данных flights, так же как в виньетке “Введение в data.table”. flights &lt;- fread(&quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/flights/NYCflights14/flights14.csv&quot;) flights # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 # 4: 2014 1 1 722 -8 1014 -26 0 AA N3EHAA 29 # 5: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 # --- # 253312: 2014 10 31 1459 1 1747 -30 0 UA N23708 1744 # 253313: 2014 10 31 854 -5 1147 -14 0 UA N33132 1758 # 253314: 2014 10 31 1102 -8 1311 16 0 MQ N827MQ 3591 # 253315: 2014 10 31 1106 -4 1325 15 0 MQ N511MQ 3592 # 253316: 2014 10 31 824 -5 1045 1 0 MQ N813MQ 3599 # origin dest air_time distance hour min # 1: JFK LAX 359 2475 9 14 # 2: JFK LAX 363 2475 11 57 # 3: JFK LAX 351 2475 19 2 # 4: LGA PBI 157 1035 7 22 # 5: JFK LAX 350 2475 13 47 # --- # 253312: LGA IAH 201 1416 14 59 # 253313: EWR IAH 189 1400 8 54 # 253314: LGA RDU 83 431 11 2 # 253315: LGA DTW 75 502 11 6 # 253316: LGA SDF 110 659 8 24 dim(flights) # [1] 253316 17 3.2 Введение В этой виньетке мы: сперва коротко обсудим семантику ссылок и рассмотрим две разные формы использования оператора := затем увидим, как мы можем добавлять/обновлять/удалять столбцы по ссылке в j с использованием :=, и как это комбинировать с i и by и, наконец, мы увидим, как использовать оператор := ради его побочного эффекта, и как мы можем его избежать при помощи copy(). 3.3 1. Семантика ссылок Результатом всех операций, которые мы видели в предыдущей виньетке, был новый набор данных. Мы увидим, как добавлять новые столбцы, обновлять или удалять существующие столбцы в исходных данных. 3.3.1 a) Бэкграунд Прежде чем заняться семантикой ссылок, рассмотрим следующую таблицу data.frame: DF = data.frame(ID = c(&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;,&quot;c&quot;), a = 1:6, b = 7:12, c=13:18) DF # ID a b c # 1 b 1 7 13 # 2 b 2 8 14 # 3 b 3 9 15 # 4 a 4 10 16 # 5 a 5 11 17 # 6 c 6 12 18 Когда вы выполняем: DF$c &lt;- 18:13 # (1) -- replace entire column # or DF$c[DF$ID == &quot;b&quot;] &lt;- 15:13 # (2) -- subassign in column &#39;c&#39; и (1), и (2) приводят к созданию глубокой копии всей таблицы data.frame в R версии &lt; 3.1. Данные копируются больше одного раза. Для увеличения производительности путем избегания этих ненужных копий data.table использует доступный, но неиспользуемый в R оператор :=. Большое увеличение производительности было сделано в R v3.1, в результате чего в случае (1) создается поверхностная, а не глубокая копия. Тем не менее, для (2) по-прежнему создается глубокая копия всего столбца даже в R v3.1+. Это означает, что чем больше столбцов участвуют в частичном присвоении в одном запросе, тем более глубокие копии создает R. 3.3.1.1 Поверхностная копия против глубокой копии Поверхностная копия является всего лишь копией вектора-указателя столбцов (в соответствии со столбцами в data.frame или data.table). Настоящие данные физически не копируются в памяти. С другой стороны, глубокая копия создает новую копию всех данных в новой области памяти. С использованием оператора := в data.table никакие копии не создаются ни в случае (1), ни в случае (2) независимо от используемой версии R. Причина этого в том, что оператор := на месте обновляет столбцы data.table (по ссылке). 3.3.2 b) Оператор := Может быть использован в j двумя способами: Форма LHS := RHS DT[, c(&quot;colA&quot;, &quot;colB&quot;, ...) := list(valA, valB, ...)] # when you have only one column to assign to you # can drop the quotes and list(), for convenience DT[, colA := valA] Функциональная форма DT[, `:=`(colA = valA, # valA is assigned to colA colB = valB, # valB is assigned to colB ... )] Обратите внимаени, что приведенныый выше код объясняет, как можно использовать :=. Это не рабочие примеры. Мы начнем использовать этот оператор с таблицей data.table flights в следующем разделе. Форма (a) удобна для программирования и особенно полезна, когда вы не знаете заранее столбцы для присваивания значений. С другой стороны, форма (b) удобна, когда вы хотите записать комментарии на будущее. Результат возвращается скрыто. Поскольку оператор := доступен в j, мы можем комбинировать его с операциями i и by, подобно операциям агрегирования, которые мы видели в предыдущей виньетке. Обратите внимание, что в двух формах :=, показанных выше, мы не присваиваем результат переменной, потому что не нуждаемся в этом. Исходная таблица data.table изменяется по ссылке. Давайте рассмотрим примеры, чтобы понять, что под этим подразумевается. В оставшейся части виньетки мы будем работать с набором данных flights. 3.4 2. Добавление/обновление/удаление столбцов по ссылке 3.4.1 a) Добавление столбцов по ссылке 3.4.1.0.1 - Как мы можем добавить столбцы скорость и общая задержка каждого рейса в таблицу data.table flights? flights[, `:=`(speed = distance / (air_time/60), # speed in km/hr delay = arr_delay + dep_delay)] # delay in minutes head(flights) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 JFK # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 JFK # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 JFK # 4: 2014 1 1 722 -8 1014 -26 0 AA N3EHAA 29 LGA # 5: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 JFK # 6: 2014 1 1 1824 4 2145 0 0 AA N3DEAA 119 EWR # dest air_time distance hour min speed delay # 1: LAX 359 2475 9 14 413.6490 27 # 2: LAX 363 2475 11 57 409.0909 10 # 3: LAX 351 2475 19 2 423.0769 11 # 4: PBI 157 1035 7 22 395.5414 -34 # 5: LAX 350 2475 13 47 424.2857 3 # 6: LAX 339 2454 18 24 434.3363 4 ## alternatively, using the &#39;LHS := RHS&#39; form # flights[, c(&quot;speed&quot;, &quot;delay&quot;) := list(distance/(air_time/60), arr_delay + dep_delay)] 3.4.1.1 Обратите внимание Мы не присвоили разультат переменной flights. Таблица flights теперь содержит два новых столбца. Это то, что мы подразумеваем под добавлением по ссылке. Мы использовали функциональную форму, так что мы можем добавлять комментарии сбоку для объяснения, что делают эти вычисления. Вы также можете видеть форму LHS := RHS (закомментированную). 3.4.2 b) Обновление некоторых строк в столбцах по ссылке - частичное присваивание по ссылке Давайте взглянем на все значения hours, доступные в таблице data.table flights: # get all &#39;hours&#39; in flights flights[, sort(unique(hour))] # [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Мы видим, что имеется 25 уникальных значений - есть и 0, и 24. Давайте заменим 24 на 0. 3.4.2.1 – Заменить строки, где hour == 24, на 0 # subassign by reference flights[hour == 24L, hour := 0L] Мы можем использовать i вместе с := в j тем же способом, как мы видели в виньетке “Введение в data.table”. Столбец hour заменяется 0 только для индексов строк, для которых условие hour == 24L, определенное в i, возвращает TRUE. := возвращает результат скрыто. Иногда бывает нужно увидеть результат после присваивания. Мы можем добиться этого, добавив пустой оператор [] в конце запроса, как показано ниже: flights[hour == 24L, hour := 0L][] # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 # 4: 2014 1 1 722 -8 1014 -26 0 AA N3EHAA 29 # 5: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 # --- # 253312: 2014 10 31 1459 1 1747 -30 0 UA N23708 1744 # 253313: 2014 10 31 854 -5 1147 -14 0 UA N33132 1758 # 253314: 2014 10 31 1102 -8 1311 16 0 MQ N827MQ 3591 # 253315: 2014 10 31 1106 -4 1325 15 0 MQ N511MQ 3592 # 253316: 2014 10 31 824 -5 1045 1 0 MQ N813MQ 3599 # origin dest air_time distance hour min speed delay # 1: JFK LAX 359 2475 9 14 413.6490 27 # 2: JFK LAX 363 2475 11 57 409.0909 10 # 3: JFK LAX 351 2475 19 2 423.0769 11 # 4: LGA PBI 157 1035 7 22 395.5414 -34 # 5: JFK LAX 350 2475 13 47 424.2857 3 # --- # 253312: LGA IAH 201 1416 14 59 422.6866 -29 # 253313: EWR IAH 189 1400 8 54 444.4444 -19 # 253314: LGA RDU 83 431 11 2 311.5663 8 # 253315: LGA DTW 75 502 11 6 401.6000 11 # 253316: LGA SDF 110 659 8 24 359.4545 -4 Давайте взглянем на все значения hours для проверки. # check again for &#39;24&#39; flights[, sort(unique(hour))] # [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 3.4.3 c) Удаление столбца по ссылке 3.4.3.1 – Удаление столбца delay flights[, c(&quot;delay&quot;) := NULL] head(flights) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 JFK # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 JFK # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 JFK # 4: 2014 1 1 722 -8 1014 -26 0 AA N3EHAA 29 LGA # 5: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 JFK # 6: 2014 1 1 1824 4 2145 0 0 AA N3DEAA 119 EWR # dest air_time distance hour min speed # 1: LAX 359 2475 9 14 413.6490 # 2: LAX 363 2475 11 57 409.0909 # 3: LAX 351 2475 19 2 423.0769 # 4: PBI 157 1035 7 22 395.5414 # 5: LAX 350 2475 13 47 424.2857 # 6: LAX 339 2454 18 24 434.3363 ## or using the functional form # flights[, `:=`(delay = NULL)] Присвоение значения NULL столбцу удаляет его. И это происходит мгновенно. Мы можем такое передавать имена столбцов вместо их имен в LHS, хотя хорошая практика программирования заключается в использовании имен. Когда нужно удалить всего один столбец, мы можем опустить c() и двойные кавычки и использовать для удобства просто имя столбца. Эквивалент кода выше: flights[, delay := NULL] 3.4.4 d) := вместе с группировкой при помощи by В разделе 2b мы уже видели, как использовать := совместно с i. Давайте посмотрим, как мы можем использовать := в сочетании с by. 3.4.4.1 - Как мы можем добавить новый столбец, содержащий максимальную скорость для каждой пары origin, dest? flights[, max_speed := max(speed), by=.(origin, dest)] head(flights) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 JFK # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 JFK # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 JFK # 4: 2014 1 1 722 -8 1014 -26 0 AA N3EHAA 29 LGA # 5: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 JFK # 6: 2014 1 1 1824 4 2145 0 0 AA N3DEAA 119 EWR # dest air_time distance hour min speed max_speed # 1: LAX 359 2475 9 14 413.6490 526.5957 # 2: LAX 363 2475 11 57 409.0909 526.5957 # 3: LAX 351 2475 19 2 423.0769 526.5957 # 4: PBI 157 1035 7 22 395.5414 517.5000 # 5: LAX 350 2475 13 47 424.2857 526.5957 # 6: LAX 339 2454 18 24 434.3363 518.4507 Мы добавляем новый столбец max_speed по ссылке, используя оператор :=. Мы задаем столбцы для группировки, как было показано в виньетке “Введение в data.table”. Для каждой группы было вычислено выражение max(speed), которое возвращает единственное значение. Это выражение повторяется, чтобы соответствовать длине группы. Еще раз: никакие копии не создаются. Таблица data.table flights изменяется на месте. Мы также можем задать by как символьный вектор, как мы видели в виньетке “Введение в data.table”, например, by = c(&quot;origin&quot;, &quot;dest&quot;). 3.4.5 e) Множественные столбцы и := 3.4.5.1 - Как мы может добавить еще две колонки, рассчитав max() для dep_delay и arr_delay для каждого месяца, используя .SD? in_cols = c(&quot;dep_delay&quot;, &quot;arr_delay&quot;) out_cols = c(&quot;max_dep_delay&quot;, &quot;max_arr_delay&quot;) flights[, c(out_cols) := lapply(.SD, max), by = month, .SDcols = in_cols] head(flights) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 JFK # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 JFK # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 JFK # 4: 2014 1 1 722 -8 1014 -26 0 AA N3EHAA 29 LGA # 5: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 JFK # 6: 2014 1 1 1824 4 2145 0 0 AA N3DEAA 119 EWR # dest air_time distance hour min speed max_speed max_dep_delay max_arr_delay # 1: LAX 359 2475 9 14 413.6490 526.5957 973 996 # 2: LAX 363 2475 11 57 409.0909 526.5957 973 996 # 3: LAX 351 2475 19 2 423.0769 526.5957 973 996 # 4: PBI 157 1035 7 22 395.5414 517.5000 973 996 # 5: LAX 350 2475 13 47 424.2857 526.5957 973 996 # 6: LAX 339 2454 18 24 434.3363 518.4507 973 996 Мы используем форму LHS := RHS. Сохраняем имена исходных и результирующих столбцов в отдельных переменных и передаем их в SDcols и LHS (для лучшей читаемости). Отметим, что поскольку мы допускаем присваивание по ссылке без заключения имени столбца в кавычки для случая отдельного столбца, как объясняется в разделе 2c, мы не можем записать out_cols := lapply(.SD, max). Это приведет к добавлению единственного столбца с именем out_col. Вместо этого мы должны использовать c(out_cols) или просто (out_cols). Использования ( вокруг имени переменной достаточно, чтобы различать эти два случая. Форма LHS := RHS позволяет нам работать с несколькими столбцами. В RHS для расчета max для столбцов, заданных в .SDcols, мы используем базовую функцию lapply() вместе с .SD тем же способом, как мы видели ранее в виньетке “Введение в data.table”. Возвращается список из двух элементов, содержащих максимальные значения dep_delay и arr_delay для каждой группы. Прежде чем перейти к следующему разделу, давайте удалим новые столбцы speed, max_speed, max_dep_delay и max_arr_delay. # RHS gets automatically recycled to length of LHS flights[, c(&quot;speed&quot;, &quot;max_speed&quot;, &quot;max_dep_delay&quot;, &quot;max_arr_delay&quot;) := NULL] head(flights) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 JFK # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 JFK # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 JFK # 4: 2014 1 1 722 -8 1014 -26 0 AA N3EHAA 29 LGA # 5: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 JFK # 6: 2014 1 1 1824 4 2145 0 0 AA N3DEAA 119 EWR # dest air_time distance hour min # 1: LAX 359 2475 9 14 # 2: LAX 363 2475 11 57 # 3: LAX 351 2475 19 2 # 4: PBI 157 1035 7 22 # 5: LAX 350 2475 13 47 # 6: LAX 339 2454 18 24 3.5 3 := и copy() := изменяет исходный объект по ссылке. Помимо возможностей, которые мы уже обсудили, иногда мы можем захотеть использовать возможность обновления по ссылке ради его побочного эффекта. А в других случаях может быть нежелательно изменять исходный объект, и тогда мы можем использовать функцию copy(), как мы сейчас увидим. 3.5.1 a) Использование оператора := ради его побочного эффекта Скажем, мы хотели бы создать функцию, которая будет возвращать максимальную скорость для каждого месяца. Но, в то же время, мы хотели бы добавить столбец speed в таблицу flight. Мы можем написать следующую простую функцию: foo &lt;- function(DT) { DT[, speed := distance / (air_time/60)] DT[, .(max_speed = max(speed)), by=month] } ans = foo(flights) head(flights) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 JFK # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 JFK # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 JFK # 4: 2014 1 1 722 -8 1014 -26 0 AA N3EHAA 29 LGA # 5: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 JFK # 6: 2014 1 1 1824 4 2145 0 0 AA N3DEAA 119 EWR # dest air_time distance hour min speed # 1: LAX 359 2475 9 14 413.6490 # 2: LAX 363 2475 11 57 409.0909 # 3: LAX 351 2475 19 2 423.0769 # 4: PBI 157 1035 7 22 395.5414 # 5: LAX 350 2475 13 47 424.2857 # 6: LAX 339 2454 18 24 434.3363 head(ans) # month max_speed # 1: 1 535.6425 # 2: 2 535.6425 # 3: 3 549.0756 # 4: 4 585.6000 # 5: 5 544.2857 # 6: 6 608.5714 Обратите внимание, что новый столбец speed был добавлен в таблицу data.table flights, поскольку := выполняет операции по ссылке. Поскольку DT (аргумент функции) и flights ссылаются на один и тот же объект в памяти, изменение DT также отражается на flights. ans содержит максимальную скорость для каждого месяца. 3.5.2 b) Функция copy() В предыдущем разделе мы использовали оператор := ради его побочного эффекта. Но, разумеется, это не всегда может быть желательно. Иногда мы хотели бы передать объект data.table функции и использовать оператор :=, но не хотели бы обновлять исходный объект. Мы можем достичь этого, используя функцию copy(). Функция copy() создает глубокую копию исходного объекта, и поэтому любые последующие операции обновления по ссылке, выполняемые на скопированном объекте, не влияют на исходный объект. Есть два конкретных случая, когда функция copy() имеет важное значение: В отличие от ситуации, которую мы видели в предыдущем пункте, мы можем не хотеть, чтобы таблица data.table, передаваемая функции, изменялась по ссылке. В качестве примера давайте рассмотрим задачу из предыдущего раздела, за исключением того, что не хотим изменять flights по ссылке. Сперва удалим столбец speed, созданный в предыдущем разделе. flights[, speed := NULL] Теперь мы можем выполнить задачу следующим образом: foo &lt;- function(DT) { DT &lt;- copy(DT) ## deep copy DT[, speed := distance / (air_time/60)] ## doesn&#39;t affect &#39;flights&#39; DT[, .(max_speed = max(speed)), by=month] } ans &lt;- foo(flights) head(flights) # year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin # 1: 2014 1 1 914 14 1238 13 0 AA N338AA 1 JFK # 2: 2014 1 1 1157 -3 1523 13 0 AA N335AA 3 JFK # 3: 2014 1 1 1902 2 2224 9 0 AA N327AA 21 JFK # 4: 2014 1 1 722 -8 1014 -26 0 AA N3EHAA 29 LGA # 5: 2014 1 1 1347 2 1706 1 0 AA N319AA 117 JFK # 6: 2014 1 1 1824 4 2145 0 0 AA N3DEAA 119 EWR # dest air_time distance hour min # 1: LAX 359 2475 9 14 # 2: LAX 363 2475 11 57 # 3: LAX 351 2475 19 2 # 4: PBI 157 1035 7 22 # 5: LAX 350 2475 13 47 # 6: LAX 339 2454 18 24 head(ans) # month max_speed # 1: 1 535.6425 # 2: 2 535.6425 # 3: 3 549.0756 # 4: 4 585.6000 # 5: 5 544.2857 # 6: 6 608.5714 Использование функции copy() не обновляет по ссылке таблицу data.table flights. Эта таблица не содержит столбца speed. ans содержит максимальную скорость, соответствующую каждому месяцу. Однако мы могли еще улучшить эту функциональность, делая поверхностное копирование вместо глубокого. На самом деле, мы бы очень хотели обеспечить эту функциональность в v1.9.8. Мы коснемся этой темы еще раз в виньетке “data.table design”. Когда мы сохраняем имена столбцов в переменной, например, DT_n = names(DT), а затем добавляем/обновляем/удаляем столбцы по ссылке, это также изменит DT_n, если мы не выполним copy(names(DT)). DT = data.table(x=1, y=2) DT_n = names(DT) DT_n # [1] &quot;x&quot; &quot;y&quot; ## add a new column by reference DT[, z := 3] ## DT_n also gets updated DT_n # [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; ## use `copy()` DT_n = copy(names(DT)) DT[, w := 4] ## DT_n doesn&#39;t get updated DT_n # [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; 3.6 Резюме 3.6.0.1 - Оператор := Используется для добавления/обновления/удаления столбцов по ссылке. Мы также увидели, как использовать := вместе с i и by таким же образом, как мы видели в виньетке “Введение в data.table”. Еще мы можем использовать keyby, цепочечные операции, передавать выражения в by. Синтаксис согласован. Мы можем использовать оператор := ради его побочного эффекта, или использовать copy(), чтобы не изменять исходный объект при обновлении по ссылке. Пока что мы увидели много всего, что может j, как это комбинировать с by , а также немного возможностей i. Давайте обратим наше внимание на i в следующей виньетке “Keys and fast binary search based subset” для выполнения молниеносного создания поднаборов при помощи установки ключей (keying) в data.tables. "],
["04_data.table_reshaping.html", "4 Эффективное переформатирование данных при помощи data.table 4.1 Данные 4.2 Введение 4.3 1. Базовая функциональность 4.4 2. Ограничения базового подхода melt/dcast 4.5 3. Расширенная (новая) функциональность", " 4 Эффективное переформатирование данных при помощи data.table В этой виньетке обсуждается обычное использование функций для переформатирования данных в таблицах data.tables melt (из “широкого” формата в “длинный”) и dcast (из “длинного” формата в широкий), а также новая расширенная функциональность для множественных столбцов, доступная начиная с v1.9.6. 4.1 Данные Мы будет загружать наборы данных непосредственно в разделах. 4.2 Введение Функции melt и dcast для таблиц data.tables являются расширениями соответствующих функций из пакета reshape2. В этой виньетке мы: сперва кратко рассмотрим переформатирование таблиц data.tables из “широкого” формата в “длинный”, и наоборот затем рассмотрим сценарии, когда базовая функциональность становится неэффективной и, наконец, рассмотрим новые улучшения для методов melt и dcast, которые позволяют обрабатывать несколько столбцов одновременно. Расширенная функциональность соответствует философии data.table, состоящей в эффективном и непосредственном выполнении операций. 4.2.0.1 Обратите внимание Начиная с v1.9.6, вам не нужно загружать пакет reshape2, чтобы использовать функции для таблиц data.tables. Вам нужно только загрузить data.table. Если вам нужно загрузить пакет reshape2 для манипуляций с матрицами или таблицами данных, убедитесь, что он загружается перед пакетом data.table. 4.3 1. Базовая функциональность 4.3.1 a) melting таблиц data.tables (переформатирование из “широкого” формата в “длинный”) Предположим, у нас есть искусственные данные, показанные ниже: DT = fread(&quot;https://raw.githubusercontent.com/wiki/Rdatatable/data.table/data/melt_default.csv&quot;) DT # family_id age_mother dob_child1 dob_child2 dob_child3 # 1: 1 30 1998-11-26 2000-01-29 NA # 2: 2 27 1996-06-22 NA NA # 3: 3 26 2002-07-11 2004-04-05 2007-09-02 # 4: 4 32 2004-10-10 2009-08-27 2012-07-21 # 5: 5 29 2000-12-05 2005-02-28 NA ## dob stands for date of birth. str(DT) # Classes &#39;data.table&#39; and &#39;data.frame&#39;: 5 obs. of 5 variables: # $ family_id : int 1 2 3 4 5 # $ age_mother: int 30 27 26 32 29 # $ dob_child1: chr &quot;1998-11-26&quot; &quot;1996-06-22&quot; &quot;2002-07-11&quot; &quot;2004-10-10&quot; ... # $ dob_child2: chr &quot;2000-01-29&quot; NA &quot;2004-04-05&quot; &quot;2009-08-27&quot; ... # $ dob_child3: chr NA NA &quot;2007-09-02&quot; &quot;2012-07-21&quot; ... # - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; 4.3.1.1 - Переформатировать DT в “длинную” форму, в которой каждый dob является отдельным наблюдением. Мы можем сделать это при помощи melt(), задав аргументы id.vars и measure.vars следующим образом: DT.m1 = melt(DT, id.vars = c(&quot;family_id&quot;, &quot;age_mother&quot;), measure.vars = c(&quot;dob_child1&quot;, &quot;dob_child2&quot;, &quot;dob_child3&quot;)) DT.m1 # family_id age_mother variable value # 1: 1 30 dob_child1 1998-11-26 # 2: 2 27 dob_child1 1996-06-22 # 3: 3 26 dob_child1 2002-07-11 # 4: 4 32 dob_child1 2004-10-10 # 5: 5 29 dob_child1 2000-12-05 # 6: 1 30 dob_child2 2000-01-29 # 7: 2 27 dob_child2 NA # 8: 3 26 dob_child2 2004-04-05 # 9: 4 32 dob_child2 2009-08-27 # 10: 5 29 dob_child2 2005-02-28 # 11: 1 30 dob_child3 NA # 12: 2 27 dob_child3 NA # 13: 3 26 dob_child3 2007-09-02 # 14: 4 32 dob_child3 2012-07-21 # 15: 5 29 dob_child3 NA str(DT.m1) # Classes &#39;data.table&#39; and &#39;data.frame&#39;: 15 obs. of 4 variables: # $ family_id : int 1 2 3 4 5 1 2 3 4 5 ... # $ age_mother: int 30 27 26 32 29 30 27 26 32 29 ... # $ variable : Factor w/ 3 levels &quot;dob_child1&quot;,&quot;dob_child2&quot;,..: 1 1 1 1 1 2 2 2 2 2 ... # $ value : chr &quot;1998-11-26&quot; &quot;1996-06-22&quot; &quot;2002-07-11&quot; &quot;2004-10-10&quot; ... # - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; measure.vars задает набор столбцов, которые мы хотим скомбинировать. Мы также можем задать индексы столбцов вместо имен. По умолчанию столбец variable имеет тип factor. Присвойте аргументу variable.factor значение FALSE, если вместо этого вы хотите вернуть символьный вектор. Аргумент variable.factor доступен только в функции melt из пакета data.table и не доступен в пакете reshape2 По умолчанию, “расплавленные” столбцы автоматически названы variable и value. melt сохраняет атрибуты столбца в возвращаемом результате. 4.3.1.2 - Назвать столбцы variable и value соответственно child и dob. DT.m1 = melt(DT, measure.vars = c(&quot;dob_child1&quot;, &quot;dob_child2&quot;, &quot;dob_child3&quot;), variable.name = &quot;child&quot;, value.name = &quot;dob&quot;) DT.m1 # family_id age_mother child dob # 1: 1 30 dob_child1 1998-11-26 # 2: 2 27 dob_child1 1996-06-22 # 3: 3 26 dob_child1 2002-07-11 # 4: 4 32 dob_child1 2004-10-10 # 5: 5 29 dob_child1 2000-12-05 # 6: 1 30 dob_child2 2000-01-29 # 7: 2 27 dob_child2 NA # 8: 3 26 dob_child2 2004-04-05 # 9: 4 32 dob_child2 2009-08-27 # 10: 5 29 dob_child2 2005-02-28 # 11: 1 30 dob_child3 NA # 12: 2 27 dob_child3 NA # 13: 3 26 dob_child3 2007-09-02 # 14: 4 32 dob_child3 2012-07-21 # 15: 5 29 dob_child3 NA По умолчанию, если аргумент id.vars или measure.vars пропущен, оставшиеся столбцы автоматически присваиваются пропущенному аргументу. Если не задан ни аргумент id.vars, ни аргумент measure.vars, как было упомянуто в справке ?melt, столбцы всех типов, кроме numeric, integer и logical присваиваются аргументу id.vars. Кроме того, автоматически присвоенные id.vars столбцы указываются в предупреждении. 4.3.2 b) casting таблиц data.tables (переформатирование из “длинного” формата в “широкий”) В предыдущем разделе мы увидели, как перейти от “широкой” формы к “длинной”. Давайте рассмотрим обратную операцию в этом разделе. 4.3.2.1 - Как мы можем получить обратно исходную таблицу DT из DT.m? Т.е, мы хотели бы собрать все наблюдения для детей, соответствующих каждому показателю family_id, age_mother, в одну строку. Мы можем сделать это при помощи dcast следующим образом: dcast(DT.m1, family_id + age_mother ~ child, value.var = &quot;dob&quot;) # family_id age_mother dob_child1 dob_child2 dob_child3 # 1: 1 30 1998-11-26 2000-01-29 NA # 2: 2 27 1996-06-22 NA NA # 3: 3 26 2002-07-11 2004-04-05 2007-09-02 # 4: 4 32 2004-10-10 2009-08-27 2012-07-21 # 5: 5 29 2000-12-05 2005-02-28 NA dcast использует интерфейс формул. Переменные в левой части формулы представляют идентификаторы, а переменные в правой части - измерения. value.var задает столбец, который заполняется при приведении к “широкому” формату. dcast также старается сохранять атрибуты в возвращаемом результате, когда это возможно. 4.3.2.2 - Имея DT.m, как мы можем получить количество детей в каждой семье? Вы также можете передать функцию для агрегировани в dcast с помощью аргумента fun.aggregate. Это особенно важно, когда заданная формула не идентифицирует единственное значение в каждой ячейке. dcast(DT.m1, family_id ~ ., fun.agg = function(x) sum(!is.na(x)), value.var = &quot;dob&quot;) # family_id . # 1: 1 2 # 2: 2 1 # 3: 3 3 # 4: 4 3 # 5: 5 2 См. ?dcast для других полезных аргументов и дополнительных примеров. 4.4 2. Ограничения базового подхода melt/dcast До сих пор мы видели возможности melt и dcast, основанные на пакете reshape2, но эффективно реализованные для таблиц data.tables с использованием внутренней машинерии data.table (быстрая сортировки, бинарный поиск и т.д.). Тем не менее, бывают ситуации, когда мы не можем выразить требуемые операции простым способом. Например, рассмотрим таблицу data.table, показанную ниже: DT = fread(&quot;https://raw.githubusercontent.com/wiki/Rdatatable/data.table/data/melt_enhanced.csv&quot;) DT # family_id age_mother dob_child1 dob_child2 dob_child3 gender_child1 gender_child2 gender_child3 # 1: 1 30 1998-11-26 2000-01-29 NA 1 2 NA # 2: 2 27 1996-06-22 NA NA 2 NA NA # 3: 3 26 2002-07-11 2004-04-05 2007-09-02 2 2 1 # 4: 4 32 2004-10-10 2009-08-27 2012-07-21 1 1 1 # 5: 5 29 2000-12-05 2005-02-28 NA 2 1 NA ## 1 = female, 2 = male И вы хотите скомбинировать (“слить”): столбцы dob; столбцы gender. С использованием базовой функциональности мы могли бы сделать что-нибудь подобное: DT.m1 = melt(DT, id = c(&quot;family_id&quot;, &quot;age_mother&quot;)) # Warning in melt.data.table(DT, id = c(&quot;family_id&quot;, &quot;age_mother&quot;)): &#39;measure.vars&#39; [dob_child1, # dob_child2, dob_child3, gender_child1, gender_child2, gender_child3] are not all of the same # type. By order of hierarchy, the molten data value column will be of type &#39;character&#39;. All measure # variables not of type &#39;character&#39; will be coerced to. Check DETAILS in ?melt.data.table for more on # coercion. DT.m1[, c(&quot;variable&quot;, &quot;child&quot;) := tstrsplit(variable, &quot;_&quot;, fixed=TRUE)] DT.c1 = dcast(DT.m1, family_id + age_mother + child ~ variable, value.var = &quot;value&quot;) DT.c1 # family_id age_mother child dob gender # 1: 1 30 child1 1998-11-26 1 # 2: 1 30 child2 2000-01-29 2 # 3: 1 30 child3 NA NA # 4: 2 27 child1 1996-06-22 2 # 5: 2 27 child2 NA NA # 6: 2 27 child3 NA NA # 7: 3 26 child1 2002-07-11 2 # 8: 3 26 child2 2004-04-05 2 # 9: 3 26 child3 2007-09-02 1 # 10: 4 32 child1 2004-10-10 1 # 11: 4 32 child2 2009-08-27 1 # 12: 4 32 child3 2012-07-21 1 # 13: 5 29 child1 2000-12-05 2 # 14: 5 29 child2 2005-02-28 1 # 15: 5 29 child3 NA NA str(DT.c1) ## gender column is character type now! # Classes &#39;data.table&#39; and &#39;data.frame&#39;: 15 obs. of 5 variables: # $ family_id : int 1 1 1 2 2 2 3 3 3 4 ... # $ age_mother: int 30 30 30 27 27 27 26 26 26 32 ... # $ child : chr &quot;child1&quot; &quot;child2&quot; &quot;child3&quot; &quot;child1&quot; ... # $ dob : chr &quot;1998-11-26&quot; &quot;2000-01-29&quot; NA &quot;1996-06-22&quot; ... # $ gender : chr &quot;1&quot; &quot;2&quot; NA &quot;2&quot; ... # - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; # - attr(*, &quot;sorted&quot;)= chr &quot;family_id&quot; &quot;age_mother&quot; &quot;child&quot; 4.4.0.1 Вопросы Мы хотели объединить все столбцы типа dob, а затем все столбцы типа gender. Вместо этого мы сперва объединили их все вместе, а затем разделили снова. Я думаю, легко заметить, что это весьма окольный и неэффективный путь. В качестве аналогии, представьте, что у вас есть шкаф с четырьма полками для одежды, и вы хотите собрать вместе одежду с полок 1 и 2 (на полку 1) и с полок 3 и 4 (на полку 3). Что мы делаем: собираем всю одежду вместе, а затем снова разделяем на полки 1 и 3! Объединяемые столбцы могут иметь разный тип, как в этом случае (символьный и числовой тип). При “расплавлении” столбцов их тип был приведен, как объясняется в предупреждении и показано в выводе str(DT.c1), где gender был сконвертирован в символьный тип. Мы создаем дополнительный столбец путем разделения variable на два новых столбца с весьма загадочной целью. Мы делаем это для использования функции dcast() на следующем шаге. Наконец, мы собрали набор данных. Но дело в том, что это гораздо более вычислительно дорогостоящая операция, чем “плавление”. В частности, это требует дорогостоящего вычисления порядка переменных в формуле. На самом деле, функция base::reshape способна выполнить эту операция очень простым способом. Это чрезвычайно полезная и часто недооцененная функция. Вы, безусловно, должны ее испытать! 4.5 3. Расширенная (новая) функциональность 4.5.1 a) Расширенная функция melt Поскольку мы хотим, чтобы таблицы data.tables выполняли эти операции быстро и эффективно, используя тот же интерфейс, мы пошли дальше и реализовали дополнительную функциональность, где мы можем применять функцию melt() для нескольких столбцов одновременно. 4.5.1.1 - melt() для нескольких столбцов одновременно Идея довольно проста. Мы передаем список столбцов аргументу measure.vars, где каждый элемент списка содержит столбцы, которые должны быть объединены. colA = paste(&quot;dob_child&quot;, 1:3, sep=&quot;&quot;) colB = paste(&quot;gender_child&quot;, 1:3, sep=&quot;&quot;) DT.m2 = melt(DT, measure = list(colA, colB), value.name = c(&quot;dob&quot;, &quot;gender&quot;)) DT.m2 # family_id age_mother variable dob gender # 1: 1 30 1 1998-11-26 1 # 2: 2 27 1 1996-06-22 2 # 3: 3 26 1 2002-07-11 2 # 4: 4 32 1 2004-10-10 1 # 5: 5 29 1 2000-12-05 2 # 6: 1 30 2 2000-01-29 2 # 7: 2 27 2 NA NA # 8: 3 26 2 2004-04-05 2 # 9: 4 32 2 2009-08-27 1 # 10: 5 29 2 2005-02-28 1 # 11: 1 30 3 NA NA # 12: 2 27 3 NA NA # 13: 3 26 3 2007-09-02 1 # 14: 4 32 3 2012-07-21 1 # 15: 5 29 3 NA NA str(DT.m2) ## col type is preserved # Classes &#39;data.table&#39; and &#39;data.frame&#39;: 15 obs. of 5 variables: # $ family_id : int 1 2 3 4 5 1 2 3 4 5 ... # $ age_mother: int 30 27 26 32 29 30 27 26 32 29 ... # $ variable : Factor w/ 3 levels &quot;1&quot;,&quot;2&quot;,&quot;3&quot;: 1 1 1 1 1 2 2 2 2 2 ... # $ dob : chr &quot;1998-11-26&quot; &quot;1996-06-22&quot; &quot;2002-07-11&quot; &quot;2004-10-10&quot; ... # $ gender : int 1 2 2 1 2 2 NA 2 1 1 ... # - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; 4.5.1.2 - Использование patterns() Обычно в такой ситуации можно различить столбцы, которые мы хотим “расплавить”, по общему шаблону. Мы можем использовать функцию patterns(), реализованную для удобства, чтобы предоставить поддержку регулярных выражений для объединяемых столбцов. Предыдущая операция может быть переписана как: DT.m2 = melt(DT, measure = patterns(&quot;^dob&quot;, &quot;^gender&quot;), value.name = c(&quot;dob&quot;, &quot;gender&quot;)) DT.m2 # family_id age_mother variable dob gender # 1: 1 30 1 1998-11-26 1 # 2: 2 27 1 1996-06-22 2 # 3: 3 26 1 2002-07-11 2 # 4: 4 32 1 2004-10-10 1 # 5: 5 29 1 2000-12-05 2 # 6: 1 30 2 2000-01-29 2 # 7: 2 27 2 NA NA # 8: 3 26 2 2004-04-05 2 # 9: 4 32 2 2009-08-27 1 # 10: 5 29 2 2005-02-28 1 # 11: 1 30 3 NA NA # 12: 2 27 3 NA NA # 13: 3 26 3 2007-09-02 1 # 14: 4 32 3 2012-07-21 1 # 15: 5 29 3 NA NA Вот и все! Мы можем удалить столбец variable, если нужно. Функциональность реализована полностью на C, и поэтому является не только простой, но также быстрой и эффективной с точки зрения использования памяти. 4.5.2 b) Расширенная функция dcast Отлично! Теперь мы можем “расплавить” несколько столбцов одновременно. Теперь, имея набор данных DT.m2, показанный выше, как мы можем получить обратно тот же формат, в котором были исходные данные? Используя базовую функциональность dcast, мы должны были бы “слить” данные дважды, а затем объединить результаты. Но это, опять же, многословно, сложно и неэффективно. 4.5.2.1 - Слияние нескольких value.var одновременно. Теперь мы можем одновременно задать несколько столбцов value.var в dcast для таблиц data.tables, поскольку операции выполняются внутренне и эффективно. ## new &#39;cast&#39; functionality - multiple value.vars DT.c2 = dcast(DT.m2, family_id + age_mother ~ variable, value.var = c(&quot;dob&quot;, &quot;gender&quot;)) DT.c2 # family_id age_mother dob_1 dob_2 dob_3 gender_1 gender_2 gender_3 # 1: 1 30 1998-11-26 2000-01-29 NA 1 2 NA # 2: 2 27 1996-06-22 NA NA 2 NA NA # 3: 3 26 2002-07-11 2004-04-05 2007-09-02 2 2 1 # 4: 4 32 2004-10-10 2009-08-27 2012-07-21 1 1 1 # 5: 5 29 2000-12-05 2005-02-28 NA 2 1 NA Атрибуты сохраняются для результатов, когда это возможно. Обеспечивается внутреннее и эффективное выполнение - не только быстрое, но и эффективно использующее память. 4.5.2.2 Множественные функции для fun.aggregate: Вы также можете задать множественные функции для fun.aggregate в dcast. См. примеры в ?dcast, иллюстрирующие эту функциональность. "],
["05_data.table_second_ind.html", "5 Вторичные индексы и автоиндексирование 5.1 Данные 5.2 Введение 5.3 1. Вторичные индексы 5.4 2. Быстрое создание поднаборов с использованием аргумента on и вторичных индексов 5.5 3. Автоиндексирование", " 5 Вторичные индексы и автоиндексирование Эта виньетка подразумевает знакомство читателя с синтаксисом data.table вида [i, j, by], а также с выполнением быстрого создания поднаборов на основе ключей. Если вы не знакомы с этими концепциями, пожалуйста, прочтите сперва виньетки “Введение в data.table”, “Семантика ссылок” и “Ключи и создание поднаборов на основе быстрого бинарного поиска”. 5.1 Данные Мы будем использовать набор данных flights, так же как в виньетке “Введение в data.table”. # flights &lt;- fread(&quot;flights14.csv&quot;) flights &lt;- fread(&quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/flights/NYCflights14/flights14.csv&quot;) head(flights) # year month day dep_delay arr_delay carrier origin dest air_time distance hour # 1: 2014 1 1 14 13 AA JFK LAX 359 2475 9 # 2: 2014 1 1 -3 13 AA JFK LAX 363 2475 11 # 3: 2014 1 1 2 9 AA JFK LAX 351 2475 19 # 4: 2014 1 1 -8 -26 AA LGA PBI 157 1035 7 # 5: 2014 1 1 2 1 AA JFK LAX 350 2475 13 # 6: 2014 1 1 4 0 AA EWR LAX 339 2454 18 dim(flights) # [1] 253316 11 5.2 Введение В этой виньетке мы: обсудим вторичные индексы и объясним, зачем они нужны, на примерах, когда установка ключей не является идеальным решением; вновь выполним быстрое создание поднаборов, но на этот раз с использованием нового аргумента on, который вычисляет вторичные индексы для данной задачи (временно) или использует существующие; и, наконец, рассмотрим автоиндексирование, которое позволяет пойти еще дальше и создавать вторичные индексы автоматически, но работает так же, как и нативный синтаксис R для создания поднаборов. 5.3 1. Вторичные индексы 5.3.1 a) Что такое вторичные индексы? Вторичные индексы подобны ключам keys в data.table, не считая двух основных отличий: Они физически не переупорядочивают всю таблицу data.table в ОЗУ. Вместо этого лишь вычисляется порядок [строк] для заданного набора столбцов, а соответствующий вектор хранится в качестве дополнительного атрибута под названием index. Может быть больше одного вторичного индекса в таблице data.table (как мы увидим ниже). 5.3.2 b) Установка и получение вторичных индексов 5.3.2.1 – Как мы можем задать столбец origin в качестве вторичного индекса в таблице data.table flights? setindex(flights, origin) head(flights) # year month day dep_delay arr_delay carrier origin dest air_time distance hour # 1: 2014 1 1 14 13 AA JFK LAX 359 2475 9 # 2: 2014 1 1 -3 13 AA JFK LAX 363 2475 11 # 3: 2014 1 1 2 9 AA JFK LAX 351 2475 19 # 4: 2014 1 1 -8 -26 AA LGA PBI 157 1035 7 # 5: 2014 1 1 2 1 AA JFK LAX 350 2475 13 # 6: 2014 1 1 4 0 AA EWR LAX 339 2454 18 ## alternatively we can provide character vectors to the function &#39;setindexv()&#39; # setindexv(flights, &quot;origin&quot;) # useful to program with # &#39;index&#39; attribute added names(attributes(flights)) # [1] &quot;names&quot; &quot;row.names&quot; &quot;class&quot; &quot;.internal.selfref&quot; # [5] &quot;index&quot; Функции setindex() и setindexv() позволяют добавлять вторичный индекс в таблицу data.table. Обратите внимание, что таблица flights физически не сортируется в порядке возрастания значений столбца origin, как это было бы при использовании setkey(). Также обратите внимание, что к таблице flights был добавлен атрибут index. setindex(flights, NULL) удаляет все вторичные индексы. 5.3.2.2 – Как мы можем получить все вторичные индексы, заданные для таблицы flights? indices(flights) # [1] &quot;origin&quot; setindex(flights, origin, dest) indices(flights) # [1] &quot;origin&quot; &quot;origin__dest&quot; Функция indices() возвращает все имеющиеся вторичные индексы в таблице data.table. Если нет ни одного индекса, возвращается значение NULL. Обратите внимание, что при создании другого индекса по столбцам origin, dest мы не теряем первый индекс, созданный по столбцу origin, т.е. мы можем использовать множественные вторичные индексы. 5.3.3 c) Почему нам нужны вторичные индексы? 5.3.3.1 - Переупорядочивание таблицы data.table может быть затратным и не всегда идеальным решением Рассмотрим случай, когда вы хотели бы выполнить быстрое создание поднабора на основе ключей для столбца origin и значения “JFK”. Мы будем делать это так: ## not run setkey(flights, origin) flights[&quot;JFK&quot;] # or flights[.(&quot;JFK&quot;)] setkey() требует выполнить: вычисление для заданных столбцов (в данном случае для origin) вектора, задающего порядок строк, и переупорядочивание (по ссылке) всей таблицы data.table на основе этого вектора. Вычисление упорядочивающего вектора не занимает много времени, поскольку пакет data.table использует настоящую поразрядную сортировку для числовых (integer, numeric) и символьных (character) векторов. Однако переупорядочивание таблицы может оказаться длительным процессом (в зависимости от количества строк и столбцов). Если нам не требуется повторное создание поднаборов по тому же самому столбцу, быстрое создание поднаборов на основе ключей может утратить преимущество по времени выполнения операции (в зависимости от размерности таблицы data.table). 5.3.3.2 - Ключ key может быть всего один Теперь, если мы хотим повторить ту же операцию, но для столбца dest и значения“LAX”, мы снова должна использовать setkey(). ## not run setkey(flights, dest) flights[&quot;LAX&quot;] И таблица flights снова сортируется, на этот раз по dest. В действительности нам нужна возможность быстрого создания поднаборов без этапа переупорядочивания таблицы. Вторичные индексы именно это и позволяют делать! 5.3.3.3 - Вторичные индексы могут быть использованы повторно Поскольку вторичных индексов может быть несколько, и создавать индексы так же просто, как хранить упорядочивающий вектор в качестве атрибута, это позволяет нам сэкономить время на повторном вычислении упорядочивающего вектора, если индекс уже существует. 5.3.3.4 - Новый аргумент on обеспечивает более понятный синтаксис и автоматическое создание и повторное использование вторичных индексов Как мы увидим в следующем разделе, аргумент on обеспечивает несколько преимуществ: делает возможным вычисление вторичных индексов “на лету”. Благодаря этому не нужно каждый раз использовать setindex(); позволяет повторно использовать существующие индексы путем простой проверки атрибутов; делает синтаксис понятнее, поскольку явно задаются столбцы, по которым выполняется создание поднабора. Код становится проще для понимания при последующей работе. Обратите внимание, что аргумент on также может быть использован при создании поднаборов на основе ключей. На самом деле, мы рекомендуем делать именно так для большей удобочитаемости. 5.4 2. Быстрое создание поднаборов с использованием аргумента on и вторичных индексов 5.4.1 a) Быстрое создание поднаборов в i 5.4.1.1 - Выбрать все строки, для которых значение origin соответствует “JFK”, используя on flights[&quot;JFK&quot;, on = &quot;origin&quot;] # year month day dep_delay arr_delay carrier origin dest air_time distance hour # 1: 2014 1 1 14 13 AA JFK LAX 359 2475 9 # 2: 2014 1 1 -3 13 AA JFK LAX 363 2475 11 # 3: 2014 1 1 2 9 AA JFK LAX 351 2475 19 # 4: 2014 1 1 2 1 AA JFK LAX 350 2475 13 # 5: 2014 1 1 -2 -18 AA JFK LAX 338 2475 21 # --- # 81479: 2014 10 31 -4 -21 UA JFK SFO 337 2586 17 # 81480: 2014 10 31 -2 -37 UA JFK SFO 344 2586 18 # 81481: 2014 10 31 0 -33 UA JFK LAX 320 2475 17 # 81482: 2014 10 31 -6 -38 UA JFK SFO 343 2586 9 # 81483: 2014 10 31 -6 -38 UA JFK LAX 323 2475 11 ## alternatively # flights[.(&quot;JFK&quot;), on = &quot;origin&quot;] (or) # flights[list(&quot;JFK&quot;), on = &quot;origin&quot;] Это выражение выполняет быстрое создание поднабора на основе бинарного поиска путем вычисления индекса “на лету”. Тем не менее, индекс не сохраняется автоматически в качестве атрибута. Это поведение может измениться в будущем (сейчас индес сохраняется при использовании синтаксиса вида flights[origin == &quot;JFK&quot;], о чем сказано ниже - прим. пер.). Если мы уже создали вторичный индекс при помощи setindex(), аргумент on будет повторно его использовать вместо того, чтобы заново вычислять. Мы можем это увидеть, задав verbose = TRUE: setindex(flights, origin) flights[&quot;JFK&quot;, on = &quot;origin&quot;, verbose = TRUE][1:5] # Looking for existing (secondary) index... found. Reusing index. # Starting bmerge ...done in 0 secs # year month day dep_delay arr_delay carrier origin dest air_time distance hour # 1: 2014 1 1 14 13 AA JFK LAX 359 2475 9 # 2: 2014 1 1 -3 13 AA JFK LAX 363 2475 11 # 3: 2014 1 1 2 9 AA JFK LAX 351 2475 19 # 4: 2014 1 1 2 1 AA JFK LAX 350 2475 13 # 5: 2014 1 1 -2 -18 AA JFK LAX 338 2475 21 5.4.1.2 - Как я могу создать поднабор на основе столбцов origin и dest? Например, если мы хотим создать поднабор для комбинации &quot;JFK&quot;, &quot;LAX&quot;: flights[.(&quot;JFK&quot;, &quot;LAX&quot;), on = c(&quot;origin&quot;, &quot;dest&quot;)][1:5] # year month day dep_delay arr_delay carrier origin dest air_time distance hour # 1: 2014 1 1 14 13 AA JFK LAX 359 2475 9 # 2: 2014 1 1 -3 13 AA JFK LAX 363 2475 11 # 3: 2014 1 1 2 9 AA JFK LAX 351 2475 19 # 4: 2014 1 1 2 1 AA JFK LAX 350 2475 13 # 5: 2014 1 1 -2 -18 AA JFK LAX 338 2475 21 Аргумент on принимает символьный вектор из имен столбцов в том же порядке, который задан в аргументе i. Поскольку время вычисления вторичного индекса весьма невелико, нам не нужно использовать setindex() в случае, если задача не требует повторного создания поднаборов по тому же столбцу. 5.4.2 b) Выбор в j Все обсуждаемые ниже операции не отличаются от тех, который мы уже в видели в виньетке “Ключи и создание поднаборов на основе быстрого бинарного поиска”, за исключением того, что мы используем аргумент on вместо установки ключей. 5.4.2.1 - Вернуть один столбец arr_delay как таблицу data.table для origin = &quot;LGA&quot; и dest = &quot;TPA&quot; flights[.(&quot;LGA&quot;, &quot;TPA&quot;), .(arr_delay), on = c(&quot;origin&quot;, &quot;dest&quot;)] # arr_delay # 1: 1 # 2: 14 # 3: -17 # 4: -4 # 5: -12 # --- # 1848: 39 # 1849: -24 # 1850: -12 # 1851: 21 # 1852: -11 5.4.3 c) Объединение в цепочку 5.4.3.1 - Для результата, полученного выше, использовать объединение операций в цепочку для упорядочивания столбца по убыванию flights[.(&quot;LGA&quot;, &quot;TPA&quot;), .(arr_delay), on = c(&quot;origin&quot;, &quot;dest&quot;)][order(-arr_delay)] # arr_delay # 1: 486 # 2: 380 # 3: 351 # 4: 318 # 5: 300 # --- # 1848: -40 # 1849: -43 # 1850: -46 # 1851: -48 # 1852: -49 5.4.4 d) Вычислить или выполнить в j 5.4.4.1 - Найти максимальную задержку прибытия, соответствующую origin = &quot;LGA&quot; и dest = &quot;TPA&quot; flights[.(&quot;LGA&quot;, &quot;TPA&quot;), max(arr_delay), on = c(&quot;origin&quot;, &quot;dest&quot;)] # [1] 486 5.4.5 e) Частичное присваивание по ссылке с использованием := в j Мы видели этот пример в виньетках “Семантика ссылок” и “Ключи и создание поднаборов на основе быстрого бинарного поиска”. Давайте взглянем на все значения hours, доступные в таблице flights: # get all &#39;hours&#39; in flights flights[, sort(unique(hour))] # [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Мы видим в данных 25 уникальных значений: присутствует и 0, и 24. Давайте заменим 24 на 0, но на этот раз используем on вместо ключей. flights[.(24L), hour := 0L, on = &quot;hour&quot;] Теперь давайте убедимся, что значения 24 заменены на 0 в столбце hour: flights[, sort(unique(hour))] # [1] 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Это особенно значимое преимущество частичных индексов. Ранее для обновления нескольких строк в столбце hour мы должны были использовать setkey(), переупорядочивая всю таблицу. При использовании on исходный порядок строк сохраняется, и операция выполняется гораздо быстрее! Глядя на код, также гораздо проще понять, какую операцию мы хотим выполнить. 5.4.6 f) Агрегирование с использованием by 5.4.6.1 - Получить максимальную задержку вылета для каждого месяца, соответствующую origin = &quot;JFK&quot;. Упорядочить результат по month ans &lt;- flights[&quot;JFK&quot;, max(dep_delay), keyby = month, on = &quot;origin&quot;] head(ans) # month V1 # 1: 1 881 # 2: 2 1014 # 3: 3 920 # 4: 4 1241 # 5: 5 853 # 6: 6 798 Мы должны были бы вновь задать ключ key для origin, dest, если бы не использовали аргумент on, который строит вторичные индексы “на лету”. 5.4.7 g) Аргумент mult Остальные аргументы, включая mult, работают так же, как мы видели в виньетке “Ключи и создание поднаборов на основе быстрого бинарного поиска”. Значения по умолчанию mult = &quot;all&quot;. Вместо этого мы можем выбрать возврат первой или последней подходящей строки. 5.4.7.1 - Выбрать только первые строки, для которых dest соответствует “BOS” и “DAY” flights[c(&quot;BOS&quot;, &quot;DAY&quot;), on = &quot;dest&quot;, mult = &quot;first&quot;] # year month day dep_delay arr_delay carrier origin dest air_time distance hour # 1: 2014 1 1 3 1 AA JFK BOS 39 187 12 # 2: 2014 1 1 25 35 EV EWR DAY 102 533 17 5.4.7.2 - Выбрать только последние строки, для которых origin соответствует “LGA”, “JFK”, “EWR” и dest соответствует “XNA” flights[.(c(&quot;LGA&quot;, &quot;JFK&quot;, &quot;EWR&quot;), &quot;XNA&quot;), on = c(&quot;origin&quot;, &quot;dest&quot;), mult = &quot;last&quot;] # year month day dep_delay arr_delay carrier origin dest air_time distance hour # 1: 2014 10 31 -5 -11 MQ LGA XNA 165 1147 6 # 2: NA NA NA NA NA NA JFK XNA NA NA NA # 3: 2014 10 31 -2 -25 EV EWR XNA 160 1131 6 5.4.8 h) Аргумент nomatch С помощью аргумента nomatch мы можем выбрать, что должны возвращать запросы, для которых нет соответствий: NA или ничего. 5.4.8.1 - Выбрать строки из предыдущего примера, но только если для них есть соответствия flights[.(c(&quot;LGA&quot;, &quot;JFK&quot;, &quot;EWR&quot;), &quot;XNA&quot;), mult = &quot;last&quot;, on = c(&quot;origin&quot;, &quot;dest&quot;), nomatch = 0L] # year month day dep_delay arr_delay carrier origin dest air_time distance hour # 1: 2014 10 31 -5 -11 MQ LGA XNA 165 1147 6 # 2: 2014 10 31 -2 -25 EV EWR XNA 160 1131 6 Поскольку не было рейсов между “JFK” и “XNA”, соответствующие строки были исключены из результата. 5.5 3. Автоиндексирование Сперва мы разобрали, как быстро создавать поднаборы при помощи бинарного поиска и ключей. Затем выяснили, как можно еще сильнее повысить производительность и сделать синтаксис понятнее, используя вторичные индексы. Что может быть лучше? Ответ - оптимизация нативного синтаксиса R для внутреннего использования вторичных индексов таким образом, чтобы мы получили ту же производительность без изучения нового синтаксиса. Эту операцию выполняет автоиндексирование. В данный момент оно реализовано только для бинарных операторов == и %in% и работает только для отдельных столбцов. Индекс автоматически создается и сохраняется в качестве атрибута. В этом состоит отличие от аргумента on, который каждый раз вычисляет индексы “на лету”. Давайте начнем с создания таблицы, достаточно большой для демонстрации преимущества. set.seed(1L) dt = data.table(x = sample(1e5L, 1e7L, TRUE), y = runif(100L)) print(object.size(dt), units = &quot;Mb&quot;) # 114.4 Mb Когда мы используем == или %in% для отдельного столбца в первый раз, вторичный индекс создается автоматически и используется для создания поднабора. ## посмотрим на имена атрибутов names(attributes(dt)) # [1] &quot;names&quot; &quot;row.names&quot; &quot;class&quot; &quot;.internal.selfref&quot; ## запускаем в первый раз (t1 &lt;- system.time(ans &lt;- dt[x == 989L])) # user system elapsed # 0.202 0.006 0.210 head(ans) # x y # 1: 989 0.5372007 # 2: 989 0.5642786 # 3: 989 0.7151100 # 4: 989 0.3920405 # 5: 989 0.9547465 # 6: 989 0.2914710 ## создан вторичный индекс names(attributes(dt)) # [1] &quot;names&quot; &quot;row.names&quot; &quot;class&quot; &quot;.internal.selfref&quot; # [5] &quot;index&quot; indices(dt) # [1] &quot;x&quot; Время создания поднабора в первый раз состоит из времени на создание индекса и времени на выполнение собственно создания поднабора. Поскольку создание вторичного индекса включает только создание упорядочивающего вектора, эта комбинированная операция во многих случаях выполняется быстрее, чем сканирование вектора. Но настоящее преимущество проявляется при последовательном создании поднаборов, которое выполняется исключительно быстро. ## последовательное создание поднаборов (t2 &lt;- system.time(dt[x == 989L])) # user system elapsed # 0.001 0.000 0.001 system.time(dt[x %in% 1989:2012]) # user system elapsed # 0.001 0.000 0.001 При первом запуске потребовалось 0.210 секунды, при втором - 0.001 секунды. Автоиндексирование можно отключить при помощи глобального аргумента options(datatable.auto.index = FALSE). В будущем мы планируем расширить автоиндексирование для выражений, содержащих больше одного столбца. Также мы работаем над расширением бинарного поиска для работы с другими операторами, такими как &lt;, &lt;=, &gt; и &gt;=. Мы расширим быстрое создание поднаборов с использованием ключей и вторичных индексов на объединения (joins) в следующей виньетке, “Joins and rolling joins”. "]
]
