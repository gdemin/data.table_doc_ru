<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Руководство по data.table</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="Руководство по пакету data.table: перевод виньеток, справочная иформация.">
  <meta name="generator" content="bookdown 0.1.7 and GitBook 2.6.7">

  <meta property="og:title" content="Руководство по data.table" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Руководство по пакету data.table: перевод виньеток, справочная иформация." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Руководство по data.table" />
  
  <meta name="twitter:description" content="Руководство по пакету data.table: перевод виньеток, справочная иформация." />
  

<meta name="author" content="Андрей Огурцов">

<meta name="date" content="2016-09-12">


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="04_data.table_reshaping.html">


<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>


  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html"><i class="fa fa-check"></i><b>1</b> Введение в data.table</a><ul>
<li class="chapter" data-level="1.1" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.1"><i class="fa fa-check"></i><b>1.1</b> Анализ данных с data.table</a></li>
<li class="chapter" data-level="1.2" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.2"><i class="fa fa-check"></i><b>1.2</b> Данные</a></li>
<li class="chapter" data-level="1.3" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.3"><i class="fa fa-check"></i><b>1.3</b> Введение</a></li>
<li class="chapter" data-level="1.4" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.4"><i class="fa fa-check"></i><b>1.4</b> 1. Основы</a><ul>
<li class="chapter" data-level="1.4.1" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.4.1"><i class="fa fa-check"></i><b>1.4.1</b> a) Что такое <em>data.table</em>?</a></li>
<li class="chapter" data-level="1.4.2" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.4.2"><i class="fa fa-check"></i><b>1.4.2</b> b) Общий вид - каким образом реализованы улучшения <em>data.table</em>?</a></li>
<li class="chapter" data-level="1.4.3" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#c----i"><i class="fa fa-check"></i><b>1.4.3</b> c) Выбор строк в <code id="ch1.4.3">i</code></a></li>
<li class="chapter" data-level="1.4.4" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#d----j"><i class="fa fa-check"></i><b>1.4.4</b> d) Выбор столбцов в <code id="ch1.4.4">j</code></a></li>
<li class="chapter" data-level="1.4.5" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#e-----j"><i class="fa fa-check"></i><b>1.4.5</b> e) Вычислить или <em>выполнить</em> в <code id="ch1.4.5">j</code></a></li>
<li class="chapter" data-level="1.4.6" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#f---i----j"><i class="fa fa-check"></i><b>1.4.6</b> f) Выбрать в <code>i</code> <em>и</em> выполнить в <code id="ch1.4.6">j</code></a></li>
<li class="chapter" data-level="1.4.7" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#g------------j---data.frame"><i class="fa fa-check"></i><b>1.4.7</b> g) Отлично! Но как я могу ссылаться на столбцы по именам в <code>j</code> (как в <em>data.frame</em>)?</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#section-1.5"><i class="fa fa-check"></i><b>1.5</b> 2. Агрегирования</a><ul>
<li class="chapter" data-level="1.5.1" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#a----by"><i class="fa fa-check"></i><b>1.5.1</b> a) Группировка с использованием <code>by</code></a></li>
<li class="chapter" data-level="1.5.2" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#b-keyby"><i class="fa fa-check"></i><b>1.5.2</b> b) keyby</a></li>
<li class="chapter" data-level="1.5.3" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#c-"><i class="fa fa-check"></i><b>1.5.3</b> c) Цепочки</a></li>
<li class="chapter" data-level="1.5.4" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#d---by"><i class="fa fa-check"></i><b>1.5.4</b> d) Выражения в <code>by</code></a></li>
<li class="chapter" data-level="1.5.5" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#e----j---.sd"><i class="fa fa-check"></i><b>1.5.5</b> e) Множество столбцов в <code>j</code> - <code>.SD</code></a></li>
<li class="chapter" data-level="1.5.6" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#f--.sd---"><i class="fa fa-check"></i><b>1.5.6</b> f) Поднабор <code>.SD</code> для каждой группы:</a></li>
<li class="chapter" data-level="1.5.7" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#g---j--"><i class="fa fa-check"></i><b>1.5.7</b> g) Зачем делать <code>j</code> настолько гибким?</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#section-1.6"><i class="fa fa-check"></i><b>1.6</b> Резюме</a><ul>
<li class="chapter" data-level="1.6.1" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#-i"><i class="fa fa-check"></i><b>1.6.1</b> Использование <code>i</code>:</a></li>
<li class="chapter" data-level="1.6.2" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#-j"><i class="fa fa-check"></i><b>1.6.2</b> Использование <code>j</code>:</a></li>
<li class="chapter" data-level="1.6.3" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#-by"><i class="fa fa-check"></i><b>1.6.3</b> Использование <code>by</code>:</a></li>
<li class="chapter" data-level="1.6.4" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#--"><i class="fa fa-check"></i><b>1.6.4</b> И запомните совет:</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html"><i class="fa fa-check"></i><b>2</b> Ключи и создание поднаборов на основе быстрого бинарного поиска</a><ul>
<li class="chapter" data-level="2.1" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#section-2.1"><i class="fa fa-check"></i><b>2.1</b> Данные</a></li>
<li class="chapter" data-level="2.2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#section-2.2"><i class="fa fa-check"></i><b>2.2</b> Введение</a></li>
<li class="chapter" data-level="2.3" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#section-2.3"><i class="fa fa-check"></i><b>2.3</b> 1. Ключи</a><ul>
<li class="chapter" data-level="2.3.1" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#a---"><i class="fa fa-check"></i><b>2.3.1</b> a) Что такое <em>ключ</em>?</a></li>
<li class="chapter" data-level="2.3.2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#b--------data.table"><i class="fa fa-check"></i><b>2.3.2</b> b) Установка, получение и использование ключей в таблице <em>data.table</em></a></li>
<li class="chapter" data-level="2.3.3" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#c----"><i class="fa fa-check"></i><b>2.3.3</b> c) Ключи и множественные столбцы</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#---j--by"><i class="fa fa-check"></i><b>2.4</b> 2. Комбинирование ключей с <code>j</code> и <code>by</code></a><ul>
<li class="chapter" data-level="2.4.1" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#a---j"><i class="fa fa-check"></i><b>2.4.1</b> a) Выбор в <code>j</code></a></li>
<li class="chapter" data-level="2.4.2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#b--"><i class="fa fa-check"></i><b>2.4.2</b> b) Цепочки операций</a></li>
<li class="chapter" data-level="2.4.3" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#c-----j"><i class="fa fa-check"></i><b>2.4.3</b> c) Вычислить или <em>выполнить</em> в <code>j</code></a></li>
<li class="chapter" data-level="2.4.4" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#d--------j"><i class="fa fa-check"></i><b>2.4.4</b> d) <em>Частичное присваивание</em> по ссылке с использованием <code>:=</code> в <code>j</code></a></li>
<li class="chapter" data-level="2.4.5" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#e----by"><i class="fa fa-check"></i><b>2.4.5</b> e) Агрегирование с использованием <code>by</code></a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#----mult--nomatch"><i class="fa fa-check"></i><b>2.5</b> 3. Дополнительные аргументы - <code>mult</code> и <code>nomatch</code></a><ul>
<li class="chapter" data-level="2.5.1" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#a--mult"><i class="fa fa-check"></i><b>2.5.1</b> a) Аргумент <code>mult</code></a></li>
<li class="chapter" data-level="2.5.2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#b--nomatch"><i class="fa fa-check"></i><b>2.5.2</b> b) Аргумент <code>nomatch</code></a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#------"><i class="fa fa-check"></i><b>2.6</b> 4. Бинарный поиск в сравнении со сканированием вектора</a><ul>
<li class="chapter" data-level="2.6.1" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#a---"><i class="fa fa-check"></i><b>2.6.1</b> a) Производительность бинарного поиска</a></li>
<li class="chapter" data-level="2.6.2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#b-----data.table-----"><i class="fa fa-check"></i><b>2.6.2</b> b) Почему использование ключей в <em>data.table</em> приводит к молниеносному созданию поднаборов?</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#-1"><i class="fa fa-check"></i><b>2.7</b> Резюме</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html"><i class="fa fa-check"></i><b>3</b> Семантика ссылок</a><ul>
<li class="chapter" data-level="3.1" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.1"><i class="fa fa-check"></i><b>3.1</b> Данные</a></li>
<li class="chapter" data-level="3.2" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.2"><i class="fa fa-check"></i><b>3.2</b> Введение</a></li>
<li class="chapter" data-level="3.3" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.3"><i class="fa fa-check"></i><b>3.3</b> 1. Семантика ссылок</a><ul>
<li class="chapter" data-level="3.3.1" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.3.1"><i class="fa fa-check"></i><b>3.3.1</b> a) Бэкграунд</a></li>
<li class="chapter" data-level="3.3.2" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#b-"><i class="fa fa-check"></i><b>3.3.2</b> b) Оператор <code id="ch3.3.2">:=</code></a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#add_del"><i class="fa fa-check"></i><b>3.4</b> 2. Добавление/обновление/удаление столбцов <em>по ссылке</em></a><ul>
<li class="chapter" data-level="3.4.1" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.2.1"><i class="fa fa-check"></i><b>3.4.1</b> a) Добавление столбцов по ссылке</a></li>
<li class="chapter" data-level="3.4.2" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.2.2"><i class="fa fa-check"></i><b>3.4.2</b> b) Обновление некоторых строк в столбцах по ссылке - <em>частичное присваивание</em> по ссылке</a></li>
<li class="chapter" data-level="3.4.3" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.2.3"><i class="fa fa-check"></i><b>3.4.3</b> c) Удаление столбца по ссылке</a></li>
<li class="chapter" data-level="3.4.4" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#d------by"><i class="fa fa-check"></i><b>3.4.4</b> d) <code>:=</code> вместе с группировкой при помощи <code id="ch3.2.4">by</code></a></li>
<li class="chapter" data-level="3.4.5" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#e---"><i class="fa fa-check"></i><b>3.4.5</b> e) Множественные столбцы и <code id="ch3.2.5">:=</code></a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#-copy"><i class="fa fa-check"></i><b>3.5</b> 3 <code>:=</code> и <code id="eq_copy">copy()</code></a><ul>
<li class="chapter" data-level="3.5.1" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.3.1"><i class="fa fa-check"></i><b>3.5.1</b> a) Использование оператора <code>:=</code> ради его побочного эффекта</a></li>
<li class="chapter" data-level="3.5.2" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#b--copy"><i class="fa fa-check"></i><b>3.5.2</b> b) Функция <code id="fun_copy">copy()</code></a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.4"><i class="fa fa-check"></i><b>3.6</b> Резюме</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html"><i class="fa fa-check"></i><b>4</b> Эффективное переформатирование данных при помощи data.table</a><ul>
<li class="chapter" data-level="4.1" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.1"><i class="fa fa-check"></i><b>4.1</b> Данные</a></li>
<li class="chapter" data-level="4.2" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.2"><i class="fa fa-check"></i><b>4.2</b> Введение</a></li>
<li class="chapter" data-level="4.3" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.3"><i class="fa fa-check"></i><b>4.3</b> 1. Базовая функциональность</a><ul>
<li class="chapter" data-level="4.3.1" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.3.1"><i class="fa fa-check"></i><b>4.3.1</b> a) <code>melt</code>ing таблиц <em>data.tables</em> (переформатирование из “широкого” формата в “длинный”)</a></li>
<li class="chapter" data-level="4.3.2" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.3.2"><i class="fa fa-check"></i><b>4.3.2</b> b) <code>cast</code>ing таблиц <em>data.tables</em> (переформатирование из “длинного” формата в “широкий”)</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#---meltdcast"><i class="fa fa-check"></i><b>4.4</b> 2. Ограничения базового подхода <code id="ch4.4">melt/dcast</code></a></li>
<li class="chapter" data-level="4.5" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.5"><i class="fa fa-check"></i><b>4.5</b> 3. Расширенная (новая) функциональность</a><ul>
<li class="chapter" data-level="4.5.1" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#a---melt"><i class="fa fa-check"></i><b>4.5.1</b> a) Расширенная функция <code id="ch4.5.1">melt</code></a></li>
<li class="chapter" data-level="4.5.2" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#b---dcast"><i class="fa fa-check"></i><b>4.5.2</b> b) Расширенная функция <code id="ch4.5.2">dcast</code></a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#---"><i class="fa fa-check"></i><b>5</b> Вторичные индексы и автоиндексирование</a><ul>
<li class="chapter" data-level="5.1" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html"><i class="fa fa-check"></i><b>5.1</b> Данные</a></li>
<li class="chapter" data-level="5.2" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.2"><i class="fa fa-check"></i><b>5.2</b> Введение</a></li>
<li class="chapter" data-level="5.3" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.3"><i class="fa fa-check"></i><b>5.3</b> 1. Вторичные индексы</a><ul>
<li class="chapter" data-level="5.3.1" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.3.1"><i class="fa fa-check"></i><b>5.3.1</b> a) Что такое вторичные индексы?</a></li>
<li class="chapter" data-level="5.3.2" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.3.2"><i class="fa fa-check"></i><b>5.3.2</b> b) Установка и получение вторичных индексов</a></li>
<li class="chapter" data-level="5.3.3" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.3.3"><i class="fa fa-check"></i><b>5.3.3</b> c) Почему нам нужны вторичные индексы?</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.4"><i class="fa fa-check"></i><b>5.4</b> 2. Быстрое создание поднаборов с использованием аргумента <code>on</code> и вторичных индексов</a><ul>
<li class="chapter" data-level="5.4.1" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#a-----i"><i class="fa fa-check"></i><b>5.4.1</b> a) Быстрое создание поднаборов в <code id="ch5.4.1">i</code></a></li>
<li class="chapter" data-level="5.4.2" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#b---j"><i class="fa fa-check"></i><b>5.4.2</b> b) Выбор в <code id="ch5.4.2">j</code></a></li>
<li class="chapter" data-level="5.4.3" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.4.3"><i class="fa fa-check"></i><b>5.4.3</b> c) Объединение в цепочку</a></li>
<li class="chapter" data-level="5.4.4" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#d-----j"><i class="fa fa-check"></i><b>5.4.4</b> d) Вычислить или <em>выполнить</em> в <code id="ch5.4.4">j</code></a></li>
<li class="chapter" data-level="5.4.5" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#e--------j"><i class="fa fa-check"></i><b>5.4.5</b> e) <em>Частичное присваивание</em> по ссылке с использованием <code>:=</code> в <code id="ch5.4.5">j</code></a></li>
<li class="chapter" data-level="5.4.6" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#f----by"><i class="fa fa-check"></i><b>5.4.6</b> f) Агрегирование с использованием <code id="ch5.4.6">by</code></a></li>
<li class="chapter" data-level="5.4.7" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#g--mult"><i class="fa fa-check"></i><b>5.4.7</b> g) Аргумент <code id="ch5.4.7">mult</code></a></li>
<li class="chapter" data-level="5.4.8" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#h--nomatch"><i class="fa fa-check"></i><b>5.4.8</b> h) Аргумент <code id="ch5.4.8">nomatch</code></a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.5"><i class="fa fa-check"></i><b>5.5</b> 3. Автоиндексирование</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Руководство по data.table</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="---" class="section level1">
<h1><span class="header-section-number">5</span> Вторичные индексы и автоиндексирование</h1>
<p>Эта виньетка подразумевает знакомство читателя с синтаксисом <em>data.table</em> вида <code>[i, j, by]</code>, а также с выполнением быстрого создания поднаборов на основе ключей. Если вы не знакомы с этими концепциями, пожалуйста, прочтите сперва виньетки “Введение в data.table”, “Семантика ссылок” и “Ключи и создание поднаборов на основе быстрого бинарного поиска”.</p>
<div id="ch5.1" class="section level2">
<h2><span class="header-section-number">5.1</span> Данные</h2>
<p>Мы будем использовать набор данных <code>flights</code>, так же как в виньетке “Введение в data.table”.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># flights &lt;- fread(&quot;flights14.csv&quot;)</span>
flights &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="st">&quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/flights/NYCflights14/flights14.csv&quot;</span>)
<span class="kw">head</span>(flights)
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9</span>
<span class="co"># 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11</span>
<span class="co"># 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19</span>
<span class="co"># 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7</span>
<span class="co"># 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13</span>
<span class="co"># 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18</span>
<span class="kw">dim</span>(flights)
<span class="co"># [1] 253316     11</span></code></pre></div>
</div>
<div id="ch5.2" class="section level2">
<h2><span class="header-section-number">5.2</span> Введение</h2>
<p>В этой виньетке мы:</p>
<ol style="list-style-type: decimal">
<li><p>обсудим <em>вторичные индексы</em> и объясним, зачем они нужны, на примерах, когда установка ключей не является идеальным решением;</p></li>
<li><p>вновь выполним быстрое создание поднаборов, но на этот раз с использованием нового аргумента <code>on</code>, который вычисляет вторичные индексы для данной задачи (временно) или использует существующие;</p></li>
<li><p>и, наконец, рассмотрим <em>автоиндексирование</em>, которое позволяет пойти еще дальше и создавать вторичные индексы автоматически, но работает так же, как и нативный синтаксис R для создания поднаборов.</p></li>
</ol>
</div>
<div id="ch5.3" class="section level2">
<h2><span class="header-section-number">5.3</span> 1. Вторичные индексы</h2>
<div id="ch5.3.1" class="section level3">
<h3><span class="header-section-number">5.3.1</span> a) Что такое вторичные индексы?</h3>
<p>Вторичные индексы подобны ключам <code>keys</code> в <em>data.table</em>, не считая двух основных отличий:</p>
<ul>
<li><p>Они физически не переупорядочивают всю таблицу <em>data.table</em> в ОЗУ. Вместо этого лишь вычисляется порядок [строк] для заданного набора столбцов, а соответствующий <em>вектор</em> хранится в качестве дополнительного атрибута под названием <code>index</code>.</p></li>
<li><p>Может быть больше одного вторичного индекса в таблице <em>data.table</em> (как мы увидим ниже).</p></li>
</ul>
</div>
<div id="ch5.3.2" class="section level3">
<h3><span class="header-section-number">5.3.2</span> b) Установка и получение вторичных индексов</h3>
<div id="ch5.3.2.1" class="section level4">
<h4><span class="header-section-number">5.3.2.1</span> – Как мы можем задать столбец <code>origin</code> в качестве вторичного индекса в таблице <em>data.table</em> <code>flights</code>?</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setindex</span>(flights, origin)
<span class="kw">head</span>(flights)
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9</span>
<span class="co"># 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11</span>
<span class="co"># 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19</span>
<span class="co"># 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7</span>
<span class="co"># 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13</span>
<span class="co"># 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18</span>

## alternatively we can provide character vectors to the function &#39;setindexv()&#39;
<span class="co"># setindexv(flights, &quot;origin&quot;) # useful to program with</span>

<span class="co"># &#39;index&#39; attribute added</span>
<span class="kw">names</span>(<span class="kw">attributes</span>(flights))
<span class="co"># [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;</span>
<span class="co"># [5] &quot;index&quot;</span></code></pre></div>
<ul>
<li><p>Функции <code>setindex()</code> и <code>setindexv()</code> позволяют добавлять вторичный индекс в таблицу <em>data.table</em>.</p></li>
<li><p>Обратите внимание, что таблица <code>flights</code> физически <strong>не сортируется</strong> в порядке возрастания значений столбца <code>origin</code>, как это было бы при использовании <code>setkey()</code>.</p></li>
<li><p>Также обратите внимание, что к таблице <code>flights</code> был добавлен атрибут <code>index</code>.</p></li>
<li><p><code>setindex(flights, NULL)</code> удаляет все вторичные индексы.</p></li>
</ul>
</div>
<div id="ch5.3.2.2" class="section level4">
<h4><span class="header-section-number">5.3.2.2</span> – Как мы можем получить все вторичные индексы, заданные для таблицы <code>flights</code>?</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">indices</span>(flights)
<span class="co"># [1] &quot;origin&quot;</span>

<span class="kw">setindex</span>(flights, origin, dest)
<span class="kw">indices</span>(flights)
<span class="co"># [1] &quot;origin&quot;       &quot;origin__dest&quot;</span></code></pre></div>
<ul>
<li><p>Функция <code>indices()</code> возвращает все имеющиеся вторичные индексы в таблице <em>data.table</em>. Если нет ни одного индекса, возвращается значение <code>NULL</code>.</p></li>
<li><p>Обратите внимание, что при создании другого индекса по столбцам <code>origin, dest</code> мы не теряем первый индекс, созданный по столбцу <code>origin</code>, т.е. мы можем использовать множественные вторичные индексы.</p></li>
</ul>
</div>
</div>
<div id="ch5.3.3" class="section level3">
<h3><span class="header-section-number">5.3.3</span> c) Почему нам нужны вторичные индексы?</h3>
<div id="ch5.3.3.1" class="section level4">
<h4><span class="header-section-number">5.3.3.1</span> - Переупорядочивание таблицы <em>data.table</em> может быть затратным и не всегда идеальным решением</h4>
<p>Рассмотрим случай, когда вы хотели бы выполнить быстрое создание поднабора на основе ключей для столбца <code>origin</code> и значения “JFK”. Мы будем делать это так:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## not run
<span class="kw">setkey</span>(flights, origin)
flights[<span class="st">&quot;JFK&quot;</span>] <span class="co"># or flights[.(&quot;JFK&quot;)]</span></code></pre></div>
<p><code>setkey()</code> требует выполнить:</p>
<ol style="list-style-type: lower-alpha">
<li><p>вычисление для заданных столбцов (в данном случае для <code>origin</code>) вектора, задающего порядок строк, и</p></li>
<li><p>переупорядочивание (по ссылке) всей таблицы <em>data.table</em> на основе этого вектора.</p></li>
</ol>
<p>Вычисление упорядочивающего вектора не занимает много времени, поскольку пакет data.table использует настоящую <a href="https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D1%80%D0%B0%D0%B7%D1%80%D1%8F%D0%B4%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0">поразрядную сортировку</a> для числовых (integer, numeric) и символьных (character) векторов. Однако переупорядочивание таблицы может оказаться длительным процессом (в зависимости от количества строк и столбцов).</p>
<p>Если нам не требуется повторное создание поднаборов по тому же самому столбцу, быстрое создание поднаборов на основе ключей может утратить преимущество по времени выполнения операции (в зависимости от размерности таблицы <em>data.table</em>).</p>
</div>
<div id="ch5.3.3.2" class="section level4">
<h4><span class="header-section-number">5.3.3.2</span> - Ключ <code>key</code> может быть всего один</h4>
<p>Теперь, если мы хотим повторить ту же операцию, но для столбца <code>dest</code> и значения“LAX”, мы <em>снова</em> должна использовать <code>setkey()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## not run
<span class="kw">setkey</span>(flights, dest)
flights[<span class="st">&quot;LAX&quot;</span>]</code></pre></div>
<p>И таблица <code>flights</code> <em>снова</em> сортируется, на этот раз по <code>dest</code>. В действительности нам нужна возможность быстрого создания поднаборов без этапа переупорядочивания таблицы. <em>Вторичные индексы</em> именно это и позволяют делать!</p>
</div>
<div id="ch5.3.3.3" class="section level4">
<h4><span class="header-section-number">5.3.3.3</span> - Вторичные индексы могут быть использованы повторно</h4>
<p>Поскольку вторичных индексов может быть несколько, и создавать индексы так же просто, как хранить упорядочивающий вектор в качестве атрибута, это позволяет нам сэкономить время на повторном вычислении упорядочивающего вектора, если индекс уже существует.</p>
</div>
<div id="ch5.3.3.4" class="section level4">
<h4><span class="header-section-number">5.3.3.4</span> - Новый аргумент <code>on</code> обеспечивает более понятный синтаксис и автоматическое создание и повторное использование вторичных индексов</h4>
<p>Как мы увидим в следующем разделе, аргумент <code>on</code> обеспечивает несколько преимуществ:</p>
<ul>
<li><p>делает возможным вычисление вторичных индексов “на лету”. Благодаря этому не нужно каждый раз использовать <code>setindex()</code>;</p></li>
<li><p>позволяет повторно использовать существующие индексы путем простой проверки атрибутов;</p></li>
<li><p>делает синтаксис понятнее, поскольку явно задаются столбцы, по которым выполняется создание поднабора. Код становится проще для понимания при последующей работе.</p></li>
</ul>
<p>Обратите внимание, что аргумент <code>on</code> также может быть использован при создании поднаборов на основе ключей. На самом деле, мы рекомендуем делать именно так для большей удобочитаемости.</p>
</div>
</div>
</div>
<div id="ch5.4" class="section level2">
<h2><span class="header-section-number">5.4</span> 2. Быстрое создание поднаборов с использованием аргумента <code>on</code> и вторичных индексов</h2>
<div id="a-----i" class="section level3">
<h3><span class="header-section-number">5.4.1</span> a) Быстрое создание поднаборов в <code id="ch5.4.1">i</code></h3>
<div id="------origin--jfk--on" class="section level4">
<h4><span class="header-section-number">5.4.1.1</span> - Выбрать все строки, для которых значение <code>origin</code> соответствует “JFK”, используя <code id="ch5.4.1.1">on</code></h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[<span class="st">&quot;JFK&quot;</span>, on =<span class="st"> &quot;origin&quot;</span>]
<span class="co">#        year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co">#     1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9</span>
<span class="co">#     2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11</span>
<span class="co">#     3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19</span>
<span class="co">#     4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13</span>
<span class="co">#     5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21</span>
<span class="co">#    ---                                                                              </span>
<span class="co"># 81479: 2014    10  31        -4       -21      UA    JFK  SFO      337     2586   17</span>
<span class="co"># 81480: 2014    10  31        -2       -37      UA    JFK  SFO      344     2586   18</span>
<span class="co"># 81481: 2014    10  31         0       -33      UA    JFK  LAX      320     2475   17</span>
<span class="co"># 81482: 2014    10  31        -6       -38      UA    JFK  SFO      343     2586    9</span>
<span class="co"># 81483: 2014    10  31        -6       -38      UA    JFK  LAX      323     2475   11</span>

## alternatively
<span class="co"># flights[.(&quot;JFK&quot;), on = &quot;origin&quot;] (or) </span>
<span class="co"># flights[list(&quot;JFK&quot;), on = &quot;origin&quot;]</span></code></pre></div>
<ul>
<li><p>Это выражение выполняет быстрое создание поднабора на основе бинарного поиска путем вычисления индекса “на лету”. Тем не менее, индекс не сохраняется автоматически в качестве атрибута. Это поведение может измениться в будущем (сейчас индес сохраняется при использовании синтаксиса вида <code>flights[origin == &quot;JFK&quot;]</code>, о чем сказано ниже - прим. пер.).</p></li>
<li><p>Если мы уже создали вторичный индекс при помощи <code>setindex()</code>, аргумент <code>on</code> будет повторно его использовать вместо того, чтобы заново вычислять. Мы можем это увидеть, задав <code>verbose = TRUE</code>:</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setindex</span>(flights, origin)
flights[<span class="st">&quot;JFK&quot;</span>, on =<span class="st"> &quot;origin&quot;</span>, verbose =<span class="st"> </span><span class="ot">TRUE</span>][<span class="dv">1</span>:<span class="dv">5</span>]
<span class="co"># Looking for existing (secondary) index... found. Reusing index.</span>
<span class="co"># Starting bmerge ...done in 0 secs</span>
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9</span>
<span class="co"># 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11</span>
<span class="co"># 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19</span>
<span class="co"># 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13</span>
<span class="co"># 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21</span></code></pre></div>
</div>
<div id="ch5.4.1.2" class="section level4">
<h4><span class="header-section-number">5.4.1.2</span> - Как я могу создать поднабор на основе столбцов <code>origin</code> <em>и</em> <code>dest</code>?</h4>
<p>Например, если мы хотим создать поднабор для комбинации <code>&quot;JFK&quot;, &quot;LAX&quot;</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;LAX&quot;</span>), on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>)][<span class="dv">1</span>:<span class="dv">5</span>]
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9</span>
<span class="co"># 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11</span>
<span class="co"># 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19</span>
<span class="co"># 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13</span>
<span class="co"># 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21</span></code></pre></div>
<ul>
<li><p>Аргумент <code>on</code> принимает символьный вектор из имен столбцов в том же порядке, который задан в аргументе <code>i</code>.</p></li>
<li><p>Поскольку время вычисления вторичного индекса весьма невелико, нам не нужно использовать <code>setindex()</code> в случае, если задача не требует повторного создания поднаборов по тому же столбцу.</p></li>
</ul>
</div>
</div>
<div id="b---j" class="section level3">
<h3><span class="header-section-number">5.4.2</span> b) Выбор в <code id="ch5.4.2">j</code></h3>
<p>Все обсуждаемые ниже операции не отличаются от тех, который мы уже в видели в виньетке “Ключи и создание поднаборов на основе быстрого бинарного поиска”, за исключением того, что мы используем аргумент <code>on</code> вместо установки ключей.</p>
<div id="---arr_delay---data.table--origin-lga--dest-tpa" class="section level4">
<h4><span class="header-section-number">5.4.2.1</span> - Вернуть один столбец <code>arr_delay</code> как таблицу <em>data.table</em> для <code>origin = &quot;LGA&quot;</code> и <code id="ch5.4.2.1">dest = &quot;TPA&quot;</code></h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), .(arr_delay), on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>)]
<span class="co">#       arr_delay</span>
<span class="co">#    1:         1</span>
<span class="co">#    2:        14</span>
<span class="co">#    3:       -17</span>
<span class="co">#    4:        -4</span>
<span class="co">#    5:       -12</span>
<span class="co">#   ---          </span>
<span class="co"># 1848:        39</span>
<span class="co"># 1849:       -24</span>
<span class="co"># 1850:       -12</span>
<span class="co"># 1851:        21</span>
<span class="co"># 1852:       -11</span></code></pre></div>
</div>
</div>
<div id="ch5.4.3" class="section level3">
<h3><span class="header-section-number">5.4.3</span> c) Объединение в цепочку</h3>
<div id="ch5.4.3.1" class="section level4">
<h4><span class="header-section-number">5.4.3.1</span> - Для результата, полученного выше, использовать объединение операций в цепочку для упорядочивания столбца по убыванию</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), .(arr_delay), on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>)][<span class="kw">order</span>(-arr_delay)]
<span class="co">#       arr_delay</span>
<span class="co">#    1:       486</span>
<span class="co">#    2:       380</span>
<span class="co">#    3:       351</span>
<span class="co">#    4:       318</span>
<span class="co">#    5:       300</span>
<span class="co">#   ---          </span>
<span class="co"># 1848:       -40</span>
<span class="co"># 1849:       -43</span>
<span class="co"># 1850:       -46</span>
<span class="co"># 1851:       -48</span>
<span class="co"># 1852:       -49</span></code></pre></div>
</div>
</div>
<div id="d-----j" class="section level3">
<h3><span class="header-section-number">5.4.4</span> d) Вычислить или <em>выполнить</em> в <code id="ch5.4.4">j</code></h3>
<div id="-----origin-lga--dest-tpa" class="section level4">
<h4><span class="header-section-number">5.4.4.1</span> - Найти максимальную задержку прибытия, соответствующую <code>origin = &quot;LGA&quot;</code> и <code id="ch5.4.4.1">dest = &quot;TPA&quot;</code></h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), <span class="kw">max</span>(arr_delay), on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>)]
<span class="co"># [1] 486</span></code></pre></div>
</div>
</div>
<div id="e--------j" class="section level3">
<h3><span class="header-section-number">5.4.5</span> e) <em>Частичное присваивание</em> по ссылке с использованием <code>:=</code> в <code id="ch5.4.5">j</code></h3>
<p>Мы видели этот пример в виньетках “Семантика ссылок” и “Ключи и создание поднаборов на основе быстрого бинарного поиска”. Давайте взглянем на все значения <code>hours</code>, доступные в таблице <code>flights</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get all &#39;hours&#39; in flights</span>
flights[, <span class="kw">sort</span>(<span class="kw">unique</span>(hour))]
<span class="co">#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</span></code></pre></div>
<p>Мы видим в данных 25 уникальных значений: присутствует и 0, и 24. Давайте заменим 24 на 0, но на этот раз используем <code>on</code> вместо ключей.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(24L), hour :<span class="er">=</span><span class="st"> </span>0L, on =<span class="st"> &quot;hour&quot;</span>]</code></pre></div>
<p>Теперь давайте убедимся, что значения 24 заменены на 0 в столбце <code>hour</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[, <span class="kw">sort</span>(<span class="kw">unique</span>(hour))]
<span class="co">#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23</span></code></pre></div>
<ul>
<li>Это особенно значимое преимущество частичных индексов. Ранее для обновления нескольких строк в столбце <code>hour</code> мы должны были использовать <code>setkey()</code>, переупорядочивая всю таблицу. При использовании <code>on</code> исходный порядок строк сохраняется, и операция выполняется гораздо быстрее! Глядя на код, также гораздо проще понять, какую операцию мы хотим выполнить.</li>
</ul>
</div>
<div id="f----by" class="section level3">
<h3><span class="header-section-number">5.4.6</span> f) Агрегирование с использованием <code id="ch5.4.6">by</code></h3>
<div id="--------origin-jfk.----month" class="section level4">
<h4><span class="header-section-number">5.4.6.1</span> - Получить максимальную задержку вылета для каждого месяца, соответствующую <code>origin = &quot;JFK&quot;</code>. Упорядочить результат по <code id="ch5.4.6.1">month</code></h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ans &lt;-<span class="st"> </span>flights[<span class="st">&quot;JFK&quot;</span>, <span class="kw">max</span>(dep_delay), keyby =<span class="st"> </span>month, on =<span class="st"> &quot;origin&quot;</span>]
<span class="kw">head</span>(ans)
<span class="co">#    month   V1</span>
<span class="co"># 1:     1  881</span>
<span class="co"># 2:     2 1014</span>
<span class="co"># 3:     3  920</span>
<span class="co"># 4:     4 1241</span>
<span class="co"># 5:     5  853</span>
<span class="co"># 6:     6  798</span></code></pre></div>
<ul>
<li>Мы должны были бы вновь задать ключ <code>key</code> для <code>origin, dest</code>, если бы не использовали аргумент <code>on</code>, который строит вторичные индексы “на лету”.</li>
</ul>
</div>
</div>
<div id="g--mult" class="section level3">
<h3><span class="header-section-number">5.4.7</span> g) Аргумент <code id="ch5.4.7">mult</code></h3>
<p>Остальные аргументы, включая <code>mult</code>, работают так же, как мы видели в виньетке “Ключи и создание поднаборов на основе быстрого бинарного поиска”. Значения по умолчанию <code>mult = &quot;all&quot;</code>. Вместо этого мы можем выбрать возврат первой или последней подходящей строки.</p>
<div id="ch5.4.7.1" class="section level4">
<h4><span class="header-section-number">5.4.7.1</span> - Выбрать только первые строки, для которых <code>dest</code> соответствует “BOS” и “DAY”</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[<span class="kw">c</span>(<span class="st">&quot;BOS&quot;</span>, <span class="st">&quot;DAY&quot;</span>), on =<span class="st"> &quot;dest&quot;</span>, mult =<span class="st"> &quot;first&quot;</span>]
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014     1   1         3         1      AA    JFK  BOS       39      187   12</span>
<span class="co"># 2: 2014     1   1        25        35      EV    EWR  DAY      102      533   17</span></code></pre></div>
</div>
<div id="ch5.4.7.2" class="section level4">
<h4><span class="header-section-number">5.4.7.2</span> - Выбрать только последние строки, для которых <code>origin</code> соответствует “LGA”, “JFK”, “EWR” и <code>dest</code> соответствует “XNA”</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="kw">c</span>(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;EWR&quot;</span>), <span class="st">&quot;XNA&quot;</span>), on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>), mult =<span class="st"> &quot;last&quot;</span>]
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6</span>
<span class="co"># 2:   NA    NA  NA        NA        NA      NA    JFK  XNA       NA       NA   NA</span>
<span class="co"># 3: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6</span></code></pre></div>
</div>
</div>
<div id="h--nomatch" class="section level3">
<h3><span class="header-section-number">5.4.8</span> h) Аргумент <code id="ch5.4.8">nomatch</code></h3>
<p>С помощью аргумента <code>nomatch</code> мы можем выбрать, что должны возвращать запросы, для которых нет соответствий: <code>NA</code> или ничего.</p>
<div id="ch5.4.8.1" class="section level4">
<h4><span class="header-section-number">5.4.8.1</span> - Выбрать строки из предыдущего примера, но только если для них есть соответствия</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="kw">c</span>(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;EWR&quot;</span>), <span class="st">&quot;XNA&quot;</span>), mult =<span class="st"> &quot;last&quot;</span>, on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>), nomatch =<span class="st"> </span>0L]
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6</span>
<span class="co"># 2: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6</span></code></pre></div>
<p>Поскольку не было рейсов между “JFK” и “XNA”, соответствующие строки были исключены из результата.</p>
</div>
</div>
</div>
<div id="ch5.5" class="section level2">
<h2><span class="header-section-number">5.5</span> 3. Автоиндексирование</h2>
<p>Сперва мы разобрали, как быстро создавать поднаборы при помощи бинарного поиска и ключей. Затем выяснили, как можно еще сильнее повысить производительность и сделать синтаксис понятнее, используя вторичные индексы. Что может быть лучше? Ответ - оптимизация <em>нативного синтаксиса R</em> для внутреннего использования вторичных индексов таким образом, чтобы мы получили ту же производительность без изучения нового синтаксиса.</p>
<p>Эту операцию выполняет <em>автоиндексирование</em>. В данный момент оно реализовано только для бинарных операторов <code>==</code> и <code>%in%</code> и работает только для отдельных столбцов. Индекс автоматически создается <em>и</em> сохраняется в качестве атрибута. В этом состоит отличие от аргумента <code>on</code>, который каждый раз вычисляет индексы “на лету”.</p>
<p>Давайте начнем с создания таблицы, достаточно большой для демонстрации преимущества.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(1L)
dt =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">x =</span> <span class="kw">sample</span>(1e5L, 1e7L, <span class="ot">TRUE</span>), <span class="dt">y =</span> <span class="kw">runif</span>(100L))
<span class="kw">print</span>(<span class="kw">object.size</span>(dt), <span class="dt">units =</span> <span class="st">&quot;Mb&quot;</span>)
<span class="co"># 114.4 Mb</span></code></pre></div>
<p>Когда мы используем <code>==</code> или <code>%in%</code> для отдельного столбца в первый раз, вторичный индекс создается автоматически и используется для создания поднабора.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## посмотрим на имена атрибутов
<span class="kw">names</span>(<span class="kw">attributes</span>(dt))
<span class="co"># [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;</span>

## запускаем в первый раз
(t1 &lt;-<span class="st"> </span><span class="kw">system.time</span>(ans &lt;-<span class="st"> </span>dt[x ==<span class="st"> </span>989L]))
<span class="co">#    user  system elapsed </span>
<span class="co">#   0.202   0.006   0.210</span>
<span class="kw">head</span>(ans)
<span class="co">#      x         y</span>
<span class="co"># 1: 989 0.5372007</span>
<span class="co"># 2: 989 0.5642786</span>
<span class="co"># 3: 989 0.7151100</span>
<span class="co"># 4: 989 0.3920405</span>
<span class="co"># 5: 989 0.9547465</span>
<span class="co"># 6: 989 0.2914710</span>

## создан вторичный индекс
<span class="kw">names</span>(<span class="kw">attributes</span>(dt))
<span class="co"># [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;</span>
<span class="co"># [5] &quot;index&quot;</span>

<span class="kw">indices</span>(dt)
<span class="co"># [1] &quot;x&quot;</span></code></pre></div>
<p>Время создания поднабора в первый раз состоит из времени на создание индекса и времени на выполнение собственно создания поднабора. Поскольку создание вторичного индекса включает только создание упорядочивающего вектора, эта комбинированная операция во многих случаях выполняется быстрее, чем сканирование вектора. Но настоящее преимущество проявляется при последовательном создании поднаборов, которое выполняется исключительно быстро.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## последовательное создание поднаборов
(t2 &lt;-<span class="st"> </span><span class="kw">system.time</span>(dt[x ==<span class="st"> </span>989L]))
<span class="co">#    user  system elapsed </span>
<span class="co">#   0.001   0.000   0.001</span>
<span class="kw">system.time</span>(dt[x %in%<span class="st"> </span><span class="dv">1989</span>:<span class="dv">2012</span>])
<span class="co">#    user  system elapsed </span>
<span class="co">#   0.001   0.000   0.001</span></code></pre></div>
<ul>
<li><p>При первом запуске потребовалось 0.210 секунды, при втором - 0.001 секунды.</p></li>
<li><p>Автоиндексирование можно отключить при помощи глобального аргумента <code>options(datatable.auto.index = FALSE)</code>.</p></li>
</ul>
<p>В будущем мы планируем расширить автоиндексирование для выражений, содержащих больше одного столбца. Также мы работаем над расширением бинарного поиска для работы с другими операторами, такими как <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> и <code>&gt;=</code>.</p>
<p>Мы расширим быстрое создание поднаборов с использованием ключей и вторичных индексов на объединения (joins) в следующей виньетке, “Joins and rolling joins”.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="04_data.table_reshaping.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page"><i class="fa fa-angle-left"></i></a>


<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
