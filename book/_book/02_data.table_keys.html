<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Руководство по data.table</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="Руководство по пакету data.table: перевод виньеток, справочная иформация.">
  <meta name="generator" content="bookdown 0.1.7 and GitBook 2.6.7">

  <meta property="og:title" content="Руководство по data.table" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Руководство по пакету data.table: перевод виньеток, справочная иформация." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Руководство по data.table" />
  
  <meta name="twitter:description" content="Руководство по пакету data.table: перевод виньеток, справочная иформация." />
  

<meta name="author" content="Андрей Огурцов">

<meta name="date" content="2016-09-12">


  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="01_data.table_intro.html">
<link rel="next" href="03_data.table_reference.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>


  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html"><i class="fa fa-check"></i><b>1</b> Введение в data.table</a><ul>
<li class="chapter" data-level="1.1" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.1"><i class="fa fa-check"></i><b>1.1</b> Анализ данных с data.table</a></li>
<li class="chapter" data-level="1.2" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.2"><i class="fa fa-check"></i><b>1.2</b> Данные</a></li>
<li class="chapter" data-level="1.3" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.3"><i class="fa fa-check"></i><b>1.3</b> Введение</a></li>
<li class="chapter" data-level="1.4" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.4"><i class="fa fa-check"></i><b>1.4</b> 1. Основы</a><ul>
<li class="chapter" data-level="1.4.1" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.4.1"><i class="fa fa-check"></i><b>1.4.1</b> a) Что такое <em>data.table</em>?</a></li>
<li class="chapter" data-level="1.4.2" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#ch1.4.2"><i class="fa fa-check"></i><b>1.4.2</b> b) Общий вид - каким образом реализованы улучшения <em>data.table</em>?</a></li>
<li class="chapter" data-level="1.4.3" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#c----i"><i class="fa fa-check"></i><b>1.4.3</b> c) Выбор строк в <code id="ch1.4.3">i</code></a></li>
<li class="chapter" data-level="1.4.4" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#d----j"><i class="fa fa-check"></i><b>1.4.4</b> d) Выбор столбцов в <code id="ch1.4.4">j</code></a></li>
<li class="chapter" data-level="1.4.5" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#e-----j"><i class="fa fa-check"></i><b>1.4.5</b> e) Вычислить или <em>выполнить</em> в <code id="ch1.4.5">j</code></a></li>
<li class="chapter" data-level="1.4.6" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#f---i----j"><i class="fa fa-check"></i><b>1.4.6</b> f) Выбрать в <code>i</code> <em>и</em> выполнить в <code id="ch1.4.6">j</code></a></li>
<li class="chapter" data-level="1.4.7" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#g------------j---data.frame"><i class="fa fa-check"></i><b>1.4.7</b> g) Отлично! Но как я могу ссылаться на столбцы по именам в <code>j</code> (как в <em>data.frame</em>)?</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#section-1.5"><i class="fa fa-check"></i><b>1.5</b> 2. Агрегирования</a><ul>
<li class="chapter" data-level="1.5.1" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#a----by"><i class="fa fa-check"></i><b>1.5.1</b> a) Группировка с использованием <code>by</code></a></li>
<li class="chapter" data-level="1.5.2" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#b-keyby"><i class="fa fa-check"></i><b>1.5.2</b> b) keyby</a></li>
<li class="chapter" data-level="1.5.3" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#c-"><i class="fa fa-check"></i><b>1.5.3</b> c) Цепочки</a></li>
<li class="chapter" data-level="1.5.4" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#d---by"><i class="fa fa-check"></i><b>1.5.4</b> d) Выражения в <code>by</code></a></li>
<li class="chapter" data-level="1.5.5" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#e----j---.sd"><i class="fa fa-check"></i><b>1.5.5</b> e) Множество столбцов в <code>j</code> - <code>.SD</code></a></li>
<li class="chapter" data-level="1.5.6" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#f--.sd---"><i class="fa fa-check"></i><b>1.5.6</b> f) Поднабор <code>.SD</code> для каждой группы:</a></li>
<li class="chapter" data-level="1.5.7" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#g---j--"><i class="fa fa-check"></i><b>1.5.7</b> g) Зачем делать <code>j</code> настолько гибким?</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#section-1.6"><i class="fa fa-check"></i><b>1.6</b> Резюме</a><ul>
<li class="chapter" data-level="1.6.1" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#-i"><i class="fa fa-check"></i><b>1.6.1</b> Использование <code>i</code>:</a></li>
<li class="chapter" data-level="1.6.2" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#-j"><i class="fa fa-check"></i><b>1.6.2</b> Использование <code>j</code>:</a></li>
<li class="chapter" data-level="1.6.3" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#-by"><i class="fa fa-check"></i><b>1.6.3</b> Использование <code>by</code>:</a></li>
<li class="chapter" data-level="1.6.4" data-path="01_data.table_intro.html"><a href="01_data.table_intro.html#--"><i class="fa fa-check"></i><b>1.6.4</b> И запомните совет:</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html"><i class="fa fa-check"></i><b>2</b> Ключи и создание поднаборов на основе быстрого бинарного поиска</a><ul>
<li class="chapter" data-level="2.1" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#section-2.1"><i class="fa fa-check"></i><b>2.1</b> Данные</a></li>
<li class="chapter" data-level="2.2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#section-2.2"><i class="fa fa-check"></i><b>2.2</b> Введение</a></li>
<li class="chapter" data-level="2.3" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#section-2.3"><i class="fa fa-check"></i><b>2.3</b> 1. Ключи</a><ul>
<li class="chapter" data-level="2.3.1" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#a---"><i class="fa fa-check"></i><b>2.3.1</b> a) Что такое <em>ключ</em>?</a></li>
<li class="chapter" data-level="2.3.2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#b--------data.table"><i class="fa fa-check"></i><b>2.3.2</b> b) Установка, получение и использование ключей в таблице <em>data.table</em></a></li>
<li class="chapter" data-level="2.3.3" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#c----"><i class="fa fa-check"></i><b>2.3.3</b> c) Ключи и множественные столбцы</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#---j--by"><i class="fa fa-check"></i><b>2.4</b> 2. Комбинирование ключей с <code>j</code> и <code>by</code></a><ul>
<li class="chapter" data-level="2.4.1" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#a---j"><i class="fa fa-check"></i><b>2.4.1</b> a) Выбор в <code>j</code></a></li>
<li class="chapter" data-level="2.4.2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#b--"><i class="fa fa-check"></i><b>2.4.2</b> b) Цепочки операций</a></li>
<li class="chapter" data-level="2.4.3" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#c-----j"><i class="fa fa-check"></i><b>2.4.3</b> c) Вычислить или <em>выполнить</em> в <code>j</code></a></li>
<li class="chapter" data-level="2.4.4" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#d--------j"><i class="fa fa-check"></i><b>2.4.4</b> d) <em>Частичное присваивание</em> по ссылке с использованием <code>:=</code> в <code>j</code></a></li>
<li class="chapter" data-level="2.4.5" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#e----by"><i class="fa fa-check"></i><b>2.4.5</b> e) Агрегирование с использованием <code>by</code></a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#----mult--nomatch"><i class="fa fa-check"></i><b>2.5</b> 3. Дополнительные аргументы - <code>mult</code> и <code>nomatch</code></a><ul>
<li class="chapter" data-level="2.5.1" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#a--mult"><i class="fa fa-check"></i><b>2.5.1</b> a) Аргумент <code>mult</code></a></li>
<li class="chapter" data-level="2.5.2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#b--nomatch"><i class="fa fa-check"></i><b>2.5.2</b> b) Аргумент <code>nomatch</code></a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#------"><i class="fa fa-check"></i><b>2.6</b> 4. Бинарный поиск в сравнении со сканированием вектора</a><ul>
<li class="chapter" data-level="2.6.1" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#a---"><i class="fa fa-check"></i><b>2.6.1</b> a) Производительность бинарного поиска</a></li>
<li class="chapter" data-level="2.6.2" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#b-----data.table-----"><i class="fa fa-check"></i><b>2.6.2</b> b) Почему использование ключей в <em>data.table</em> приводит к молниеносному созданию поднаборов?</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#-1"><i class="fa fa-check"></i><b>2.7</b> Резюме</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html"><i class="fa fa-check"></i><b>3</b> Семантика ссылок</a><ul>
<li class="chapter" data-level="3.1" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.1"><i class="fa fa-check"></i><b>3.1</b> Данные</a></li>
<li class="chapter" data-level="3.2" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.2"><i class="fa fa-check"></i><b>3.2</b> Введение</a></li>
<li class="chapter" data-level="3.3" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.3"><i class="fa fa-check"></i><b>3.3</b> 1. Семантика ссылок</a><ul>
<li class="chapter" data-level="3.3.1" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.3.1"><i class="fa fa-check"></i><b>3.3.1</b> a) Бэкграунд</a></li>
<li class="chapter" data-level="3.3.2" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#b-"><i class="fa fa-check"></i><b>3.3.2</b> b) Оператор <code id="ch3.3.2">:=</code></a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#add_del"><i class="fa fa-check"></i><b>3.4</b> 2. Добавление/обновление/удаление столбцов <em>по ссылке</em></a><ul>
<li class="chapter" data-level="3.4.1" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.2.1"><i class="fa fa-check"></i><b>3.4.1</b> a) Добавление столбцов по ссылке</a></li>
<li class="chapter" data-level="3.4.2" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.2.2"><i class="fa fa-check"></i><b>3.4.2</b> b) Обновление некоторых строк в столбцах по ссылке - <em>частичное присваивание</em> по ссылке</a></li>
<li class="chapter" data-level="3.4.3" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.2.3"><i class="fa fa-check"></i><b>3.4.3</b> c) Удаление столбца по ссылке</a></li>
<li class="chapter" data-level="3.4.4" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#d------by"><i class="fa fa-check"></i><b>3.4.4</b> d) <code>:=</code> вместе с группировкой при помощи <code id="ch3.2.4">by</code></a></li>
<li class="chapter" data-level="3.4.5" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#e---"><i class="fa fa-check"></i><b>3.4.5</b> e) Множественные столбцы и <code id="ch3.2.5">:=</code></a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#-copy"><i class="fa fa-check"></i><b>3.5</b> 3 <code>:=</code> и <code id="eq_copy">copy()</code></a><ul>
<li class="chapter" data-level="3.5.1" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.3.1"><i class="fa fa-check"></i><b>3.5.1</b> a) Использование оператора <code>:=</code> ради его побочного эффекта</a></li>
<li class="chapter" data-level="3.5.2" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#b--copy"><i class="fa fa-check"></i><b>3.5.2</b> b) Функция <code id="fun_copy">copy()</code></a></li>
</ul></li>
<li class="chapter" data-level="3.6" data-path="03_data.table_reference.html"><a href="03_data.table_reference.html#ch3.4"><i class="fa fa-check"></i><b>3.6</b> Резюме</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html"><i class="fa fa-check"></i><b>4</b> Эффективное переформатирование данных при помощи data.table</a><ul>
<li class="chapter" data-level="4.1" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.1"><i class="fa fa-check"></i><b>4.1</b> Данные</a></li>
<li class="chapter" data-level="4.2" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.2"><i class="fa fa-check"></i><b>4.2</b> Введение</a></li>
<li class="chapter" data-level="4.3" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.3"><i class="fa fa-check"></i><b>4.3</b> 1. Базовая функциональность</a><ul>
<li class="chapter" data-level="4.3.1" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.3.1"><i class="fa fa-check"></i><b>4.3.1</b> a) <code>melt</code>ing таблиц <em>data.tables</em> (переформатирование из “широкого” формата в “длинный”)</a></li>
<li class="chapter" data-level="4.3.2" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.3.2"><i class="fa fa-check"></i><b>4.3.2</b> b) <code>cast</code>ing таблиц <em>data.tables</em> (переформатирование из “длинного” формата в “широкий”)</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#---meltdcast"><i class="fa fa-check"></i><b>4.4</b> 2. Ограничения базового подхода <code id="ch4.4">melt/dcast</code></a></li>
<li class="chapter" data-level="4.5" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#ch4.5"><i class="fa fa-check"></i><b>4.5</b> 3. Расширенная (новая) функциональность</a><ul>
<li class="chapter" data-level="4.5.1" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#a---melt"><i class="fa fa-check"></i><b>4.5.1</b> a) Расширенная функция <code id="ch4.5.1">melt</code></a></li>
<li class="chapter" data-level="4.5.2" data-path="04_data.table_reshaping.html"><a href="04_data.table_reshaping.html#b---dcast"><i class="fa fa-check"></i><b>4.5.2</b> b) Расширенная функция <code id="ch4.5.2">dcast</code></a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="02_data.table_keys.html"><a href="02_data.table_keys.html#---"><i class="fa fa-check"></i><b>5</b> Вторичные индексы и автоиндексирование</a><ul>
<li class="chapter" data-level="5.1" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html"><i class="fa fa-check"></i><b>5.1</b> Данные</a></li>
<li class="chapter" data-level="5.2" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.2"><i class="fa fa-check"></i><b>5.2</b> Введение</a></li>
<li class="chapter" data-level="5.3" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.3"><i class="fa fa-check"></i><b>5.3</b> 1. Вторичные индексы</a><ul>
<li class="chapter" data-level="5.3.1" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.3.1"><i class="fa fa-check"></i><b>5.3.1</b> a) Что такое вторичные индексы?</a></li>
<li class="chapter" data-level="5.3.2" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.3.2"><i class="fa fa-check"></i><b>5.3.2</b> b) Установка и получение вторичных индексов</a></li>
<li class="chapter" data-level="5.3.3" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.3.3"><i class="fa fa-check"></i><b>5.3.3</b> c) Почему нам нужны вторичные индексы?</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.4"><i class="fa fa-check"></i><b>5.4</b> 2. Быстрое создание поднаборов с использованием аргумента <code>on</code> и вторичных индексов</a><ul>
<li class="chapter" data-level="5.4.1" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#a-----i"><i class="fa fa-check"></i><b>5.4.1</b> a) Быстрое создание поднаборов в <code id="ch5.4.1">i</code></a></li>
<li class="chapter" data-level="5.4.2" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#b---j"><i class="fa fa-check"></i><b>5.4.2</b> b) Выбор в <code id="ch5.4.2">j</code></a></li>
<li class="chapter" data-level="5.4.3" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.4.3"><i class="fa fa-check"></i><b>5.4.3</b> c) Объединение в цепочку</a></li>
<li class="chapter" data-level="5.4.4" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#d-----j"><i class="fa fa-check"></i><b>5.4.4</b> d) Вычислить или <em>выполнить</em> в <code id="ch5.4.4">j</code></a></li>
<li class="chapter" data-level="5.4.5" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#e--------j"><i class="fa fa-check"></i><b>5.4.5</b> e) <em>Частичное присваивание</em> по ссылке с использованием <code>:=</code> в <code id="ch5.4.5">j</code></a></li>
<li class="chapter" data-level="5.4.6" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#f----by"><i class="fa fa-check"></i><b>5.4.6</b> f) Агрегирование с использованием <code id="ch5.4.6">by</code></a></li>
<li class="chapter" data-level="5.4.7" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#g--mult"><i class="fa fa-check"></i><b>5.4.7</b> g) Аргумент <code id="ch5.4.7">mult</code></a></li>
<li class="chapter" data-level="5.4.8" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#h--nomatch"><i class="fa fa-check"></i><b>5.4.8</b> h) Аргумент <code id="ch5.4.8">nomatch</code></a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="05_data.table_second_ind.html"><a href="05_data.table_second_ind.html#ch5.5"><i class="fa fa-check"></i><b>5.5</b> 3. Автоиндексирование</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Руководство по data.table</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="--------" class="section level1">
<h1><span class="header-section-number">2</span> Ключи и создание поднаборов на основе быстрого бинарного поиска</h1>
<p>Эта виньетка предназначена для тех, кто уже знаком с синтаксисом <em>data.table</em>, его общим видом, тем, как выбирать строки в <code>i</code>, выбирать и вычислять столбцы, добавлять/изменять/удалять столбцы по ссылке в <code>j</code> и выполнять группировку при помощи <code>by</code>. Если вы не знакомы с этими концепциями, пожалуйста, прочтите сперва виньетки “Введение в data.table” и “Семантика ссылок”.</p>
<div id="section-2.1" class="section level2">
<h2><span class="header-section-number">2.1</span> Данные</h2>
<p>Мы будем использовать набор данных <code>flights</code>, так же как в виньетке “Введение в data.table”.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="st">&quot;https://raw.githubusercontent.com/wiki/arunsrinivasan/flights/NYCflights14/flights14.csv&quot;</span>)
<span class="kw">head</span>(flights)
<span class="co">#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin</span>
<span class="co"># 1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK</span>
<span class="co"># 2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK</span>
<span class="co"># 3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK</span>
<span class="co"># 4: 2014     1   1      722        -8     1014       -26         0      AA  N3EHAA     29    LGA</span>
<span class="co"># 5: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK</span>
<span class="co"># 6: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR</span>
<span class="co">#    dest air_time distance hour min</span>
<span class="co"># 1:  LAX      359     2475    9  14</span>
<span class="co"># 2:  LAX      363     2475   11  57</span>
<span class="co"># 3:  LAX      351     2475   19   2</span>
<span class="co"># 4:  PBI      157     1035    7  22</span>
<span class="co"># 5:  LAX      350     2475   13  47</span>
<span class="co"># 6:  LAX      339     2454   18  24</span>
<span class="kw">dim</span>(flights)
<span class="co"># [1] 253316     17</span></code></pre></div>
</div>
<div id="section-2.2" class="section level2">
<h2><span class="header-section-number">2.2</span> Введение</h2>
<p>В этой виньетке мы:</p>
<ol style="list-style-type: decimal">
<li><p>сперва введем понятие ключа <code>key</code> в таблице <em>data.table</em>, а также зададим и используем ключи для создания поднаборов в <code>i</code> на основе <em>быстрого бинарного поиска</em></p></li>
<li><p>увидим, как можно комбинировать создание поднаборов на основе ключей с <code>j</code> и <code>by</code> тем же способом, что и раньше</p></li>
<li><p>взглянем на другие полезные аргументы - <code>mult</code> и <code>nomatch</code></p></li>
<li><p>и, в заключение, оценим преимущество использования ключей - выполним создание поднаборов на основе <em>быстрого бинарного поиска</em> и сравним с традиционным подходом, который состоит в сканировании вектора.</p></li>
</ol>
</div>
<div id="section-2.3" class="section level2">
<h2><span class="header-section-number">2.3</span> 1. Ключи</h2>
<div id="a---" class="section level3">
<h3><span class="header-section-number">2.3.1</span> a) Что такое <em>ключ</em>?</h3>
<p>В виньетке “Введение в data.table” мы видели, как выбирать поднаборы строк в <code>i</code> при помощи логических выражений, номеров строк и с использованием <code>order()</code>. В этом разделе мы рассмотрим другой способ невероятно быстрого создания поднаборов - при помощи <em>ключей</em>.</p>
<p>Давайте сперва взглянем на таблицы <em>data.frames</em>. Все они имеют атрибут имен строк. Рассмотрим <em>data.frame</em> <code>DF</code> ниже.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(1L)
DF =<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">ID1 =</span> <span class="kw">sample</span>(letters[<span class="dv">1</span>:<span class="dv">2</span>], <span class="dv">10</span>, <span class="ot">TRUE</span>), 
                <span class="dt">ID2 =</span> <span class="kw">sample</span>(<span class="dv">1</span>:<span class="dv">3</span>, <span class="dv">10</span>, <span class="ot">TRUE</span>),
                <span class="dt">val =</span> <span class="kw">sample</span>(<span class="dv">10</span>), 
                <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>,
                <span class="dt">row.names =</span> <span class="kw">sample</span>(LETTERS[<span class="dv">1</span>:<span class="dv">10</span>]))
DF
<span class="co">#   ID1 ID2 val</span>
<span class="co"># C   a   3   5</span>
<span class="co"># D   a   1   6</span>
<span class="co"># E   b   2   4</span>
<span class="co"># G   a   1   2</span>
<span class="co"># B   b   1  10</span>
<span class="co"># H   a   2   8</span>
<span class="co"># I   b   1   9</span>
<span class="co"># F   b   2   1</span>
<span class="co"># J   a   3   7</span>
<span class="co"># A   b   2   3</span>

<span class="kw">rownames</span>(DF)
<span class="co">#  [1] &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;G&quot; &quot;B&quot; &quot;H&quot; &quot;I&quot; &quot;F&quot; &quot;J&quot; &quot;A&quot;</span></code></pre></div>
<p>Мы можем <em>выбрать</em> отдельную строку, используя ее имя, как показано ниже:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DF[<span class="st">&quot;C&quot;</span>, ]
<span class="co">#   ID1 ID2 val</span>
<span class="co"># C   a   3   5</span></code></pre></div>
<p>Т.е. имена строк представляют собой (более или менее) <em>индексы</em> строк в таблице <em>data.frame</em>. Однако,</p>
<ol style="list-style-type: decimal">
<li>Каждая строка ограничена <em>ровно одним</em> именем.</li>
</ol>
<p>Но, например, человек имеет <em>имя</em> и <em>фамилию</em>. Телефонный справочник удобно организовать сначала по <em>фамилии</em>, затем по <em>имени</em>.</p>
<ol start="2" style="list-style-type: decimal">
<li>Кроме того, имена строк должны быть <em>уникальными</em>.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">rownames</span>(DF) =<span class="st"> </span><span class="kw">sample</span>(LETTERS[<span class="dv">1</span>:<span class="dv">5</span>], <span class="dv">10</span>, <span class="ot">TRUE</span>)
<span class="co"># Warning: non-unique values when setting &#39;row.names&#39;: &#39;C&#39;, &#39;D&#39;</span>
<span class="co"># Error in `row.names&lt;-.data.frame`(`*tmp*`, value = value): duplicate &#39;row.names&#39; are not allowed</span></code></pre></div>
<p>Теперь давайте сконвертируем эту таблицу в <em>data.table</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">DT =<span class="st"> </span><span class="kw">as.data.table</span>(DF)
DT
<span class="co">#     ID1 ID2 val</span>
<span class="co">#  1:   a   3   5</span>
<span class="co">#  2:   a   1   6</span>
<span class="co">#  3:   b   2   4</span>
<span class="co">#  4:   a   1   2</span>
<span class="co">#  5:   b   1  10</span>
<span class="co">#  6:   a   2   8</span>
<span class="co">#  7:   b   1   9</span>
<span class="co">#  8:   b   2   1</span>
<span class="co">#  9:   a   3   7</span>
<span class="co"># 10:   b   2   3</span>

<span class="kw">rownames</span>(DT)
<span class="co">#  [1] &quot;1&quot;  &quot;2&quot;  &quot;3&quot;  &quot;4&quot;  &quot;5&quot;  &quot;6&quot;  &quot;7&quot;  &quot;8&quot;  &quot;9&quot;  &quot;10&quot;</span></code></pre></div>
<ul>
<li><p>Обратите внимание, что имена строк были удалены.</p></li>
<li><p><em>data.tables</em> никогда не используют имена строк. Так как <em>data.tables</em> <strong>наследуют</strong> <em>data.frames</em>, они по-прежнему имеют атрибут имен строк, но никогда его не используют. Вскоре мы увидим, почему.</p></li>
</ul>
<p>Если вы хотите сохранить имена строк, используйте <code>keep.rownames = TRUE</code> в <code>as.data.table()</code> - это создаст новый столбец <code>rn</code> и присвоит ему имена строк.</p>
<p>Вместо этого, в <em>data.tables</em> мы задаем и используем ключи <code>keys</code>. Думайте о них как о <strong>“заряженных” именах строк</strong>.</p>
<div id="---" class="section level4">
<h4><span class="header-section-number">2.3.1.1</span> Ключи и их свойства</h4>
<ol style="list-style-type: decimal">
<li><p>Мы можем устанавливать ключи для <em>множественных столбцов</em>, которые могут иметь <em>разные типы</em> - <em>integer, numeric, character, factor, integer64</em> и т.д. Списки и комплексные числа пока не поддерживаются.</p></li>
<li><p>Уникальность не обеспечивается, т.е. допускаются повторяющиеся значения ключа. Поскольку строки отсортированы по ключу, любые дубликаты в ключевых столбцах отображаются последовательно.</p></li>
<li><p>Установка ключа <code>key</code> <em>делает две вещи</em>:</p></li>
</ol>
<ol style="list-style-type: lower-alpha">
<li><p>переупорядочивает строки в таблице <em>data.table</em> по столбцам, предоставленным <em>по ссылке</em>, всегда в порядке <em>по возрастанию</em>.</p></li>
<li><p>отмечает эти столбцы в качестве <em>ключевых</em> столбцов путем установки атрибута <code>sorted</code> таблицы <em>data.table</em>.</p></li>
</ol>
<p>Поскольку строки переупорядочены, таблица <em>data.table</em> может иметь не более одного ключа, поскольку она не может быть отсортирована более чем одним способом [одновременно].</p>
<p>Далее в этой виньетке мы будем работать с набором данных <code>flights</code>.</p>
</div>
</div>
<div id="b--------data.table" class="section level3">
<h3><span class="header-section-number">2.3.2</span> b) Установка, получение и использование ключей в таблице <em>data.table</em></h3>
<div id="-----origin------data.table-flights" class="section level4">
<h4><span class="header-section-number">2.3.2.1</span> - Как мы можем установить столбец <code>origin</code> в качестве ключа в таблице <em>data.table</em> <code>flights</code>?</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setkey</span>(flights, origin)
<span class="kw">head</span>(flights)
<span class="co">#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin</span>
<span class="co"># 1: 2014     1   1     1824         4     2145         0         0      AA  N3DEAA    119    EWR</span>
<span class="co"># 2: 2014     1   1     1655        -5     2003       -17         0      AA  N5CFAA    172    EWR</span>
<span class="co"># 3: 2014     1   1     1611       191     1910       185         0      AA  N471AA    300    EWR</span>
<span class="co"># 4: 2014     1   1     1449        -1     1753        -2         0      AA  N4WNAA    320    EWR</span>
<span class="co"># 5: 2014     1   1      607        -3      905       -10         0      AA  N5DMAA   1205    EWR</span>
<span class="co"># 6: 2014     1   1      949         4     1243       -17         0      AA  N491AA   1223    EWR</span>
<span class="co">#    dest air_time distance hour min</span>
<span class="co"># 1:  LAX      339     2454   18  24</span>
<span class="co"># 2:  MIA      161     1085   16  55</span>
<span class="co"># 3:  DFW      214     1372   16  11</span>
<span class="co"># 4:  DFW      214     1372   14  49</span>
<span class="co"># 5:  MIA      154     1085    6   7</span>
<span class="co"># 6:  DFW      215     1372    9  49</span>

## alternatively we can provide character vectors to the function &#39;setkeyv()&#39;
<span class="co"># setkeyv(flights, &quot;origin&quot;) # useful to program with</span></code></pre></div>
<ul>
<li><p>Мы можем использовать функцию <code>setkey()</code> и передавать имена столбцов (без кавычек). Это полезно при интерактивном использовании.</p></li>
<li><p>В качестве альтернативы, вы можете передавать символьный вектор имен строк функции <code>setkeyv()</code>. Это особенно полезно при проектировании функций для передачи столбцов для установки ключей в качестве аргументов.</p></li>
<li><p>Обратите внимание, что мы не должны присваивать результаты переменной. Так происходит, потому что <code>setkey()</code> и <code>setkeyv()</code> изменяют исходную таблицу <em>data.table</em> <em>по ссылке</em> подобно <code>:=</code>, как мы видели в виньетке “Введение в data.table”. Результат возвращается скрыто.</p></li>
<li><p>Таблица <em>data.table</em> теперь переупорядочена (или отсортирована) по указанному столбцу - <code>origin</code>. Поскольку мы переупорядочивали по ссылке, требуется лишь дополнительный объем памяти для столбца, длина которого равна количеству строк в <em>data.table</em>; это опеспечивает эффективность использования памяти.</p></li>
<li><p>Вы также можете задавать ключи непосредственно при создании таблицы <em>data.table</em> при помощи функции <code>data.table()</code>, используя аргумент <code>key=</code>. Он принимает символьный вектор имен столбцов.</p></li>
</ul>
</div>
<div id="set-" class="section level4">
<h4><span class="header-section-number">2.3.2.2</span> <code>set*</code> и <code>:=</code>:</h4>
<p>В <em>data.table</em> только оператор <code>:=</code> и все функции вида <code>set*</code> (например, <code>setkey</code>, <code>setorder</code>, <code>setnames</code> и т.д.) изменяют исходный объект <em>по ссылке</em>.</p>
<p>Как только вы задали определенные <em>ключевые</em> столбцы в таблице <em>data.table</em>, вы можете выбирать поднаборы при помощи запросов по этим ключевым столбцам с использованием <code>.()</code> в <code>i</code>. Напомним, что <code>.()</code> является <em>псевдонимом</em> для <code>list()</code>.</p>
</div>
<div id="---origin----------jfk" class="section level4">
<h4><span class="header-section-number">2.3.2.3</span> - Использование ключевого столбца <code>origin</code> для выбора всех строк, для которых аэропортом отправки является “JFK”</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;JFK&quot;</span>)]
<span class="co">#        year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin</span>
<span class="co">#     1: 2014     1   1      914        14     1238        13         0      AA  N338AA      1    JFK</span>
<span class="co">#     2: 2014     1   1     1157        -3     1523        13         0      AA  N335AA      3    JFK</span>
<span class="co">#     3: 2014     1   1     1902         2     2224         9         0      AA  N327AA     21    JFK</span>
<span class="co">#     4: 2014     1   1     1347         2     1706         1         0      AA  N319AA    117    JFK</span>
<span class="co">#     5: 2014     1   1     2133        -2       37       -18         0      AA  N323AA    185    JFK</span>
<span class="co">#    ---                                                                                             </span>
<span class="co"># 81479: 2014    10  31     1705        -4     2024       -21         0      UA  N596UA    512    JFK</span>
<span class="co"># 81480: 2014    10  31     1827        -2     2133       -37         0      UA  N568UA    514    JFK</span>
<span class="co"># 81481: 2014    10  31     1753         0     2039       -33         0      UA  N518UA    535    JFK</span>
<span class="co"># 81482: 2014    10  31      924        -6     1228       -38         0      UA  N512UA    541    JFK</span>
<span class="co"># 81483: 2014    10  31     1124        -6     1408       -38         0      UA  N590UA    703    JFK</span>
<span class="co">#        dest air_time distance hour min</span>
<span class="co">#     1:  LAX      359     2475    9  14</span>
<span class="co">#     2:  LAX      363     2475   11  57</span>
<span class="co">#     3:  LAX      351     2475   19   2</span>
<span class="co">#     4:  LAX      350     2475   13  47</span>
<span class="co">#     5:  LAX      338     2475   21  33</span>
<span class="co">#    ---                                </span>
<span class="co"># 81479:  SFO      337     2586   17   5</span>
<span class="co"># 81480:  SFO      344     2586   18  27</span>
<span class="co"># 81481:  LAX      320     2475   17  53</span>
<span class="co"># 81482:  SFO      343     2586    9  24</span>
<span class="co"># 81483:  LAX      323     2475   11  24</span>

## alternatively
<span class="co"># flights[J(&quot;JFK&quot;)] (or) flights[list(&quot;JFK&quot;)]</span></code></pre></div>
<ul>
<li><p><em>ключевым</em> столбцом уже был задан столбец <code>origin</code>, поэтому достаточно напрямую передать значение, в данном случае “JFK”. Синтаксис <code>.()</code> помогает определить, что задача требует поиска значения “JFK” в ключевом столбце таблицы <em>data.table</em> (в данном случае это столбец <code>origin</code>)</p></li>
<li><p>Сперва получены <em>индексы строк</em>, соответствующих значению “JFK” в <code>origin</code>. И, поскольку в <code>j</code> нет никакого выражения, возвращены все столбцы для этих индексов строк.</p></li>
<li><p>Для отдельного ключевого столбца символьного типа вы можете опустить <code>.()</code> и использовать значения непосредственно, подобно созданию поднабора в <em>data.frames</em> с использованием имен строк.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[<span class="st">&quot;JFK&quot;</span>]              ## same as flights[.(&quot;JFK&quot;)]</code></pre></div>
<ul>
<li>Мы можем выбрать любой поднабор значений в соответствии с требованиями.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[<span class="kw">c</span>(<span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;LGA&quot;</span>)]    ## same as flights[.(c(&quot;JFK&quot;, &quot;LGA&quot;))]</code></pre></div>
<p>Это выражение вернет все столбцы со строками, соответствующими значениям “JFK” или “LGA” для столбца <code>origin</code>.</p>
</div>
<div id="-------data.table" class="section level4">
<h4><span class="header-section-number">2.3.2.4</span> - Как мы можем получить ключевые столбцы таблицы <em>data.table</em>?</h4>
<p>Используем функцию <code>key()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">key</span>(flights)
<span class="co"># [1] &quot;origin&quot;</span></code></pre></div>
<ul>
<li><p>Функция возвращает символьный вектор со всеми ключевыми столбцами</p></li>
<li><p>Если ключи не заданы, возвращается <code>NULL</code>.</p></li>
</ul>
</div>
</div>
<div id="c----" class="section level3">
<h3><span class="header-section-number">2.3.3</span> c) Ключи и множественные столбцы</h3>
<p>Напомним, что <em>ключи</em> - это как <strong>заряженные</strong> имена строк. Мы можем задавать ключи для множественных столбцов разных типов.</p>
<div id="-------origin--dest" class="section level4">
<h4><span class="header-section-number">2.3.3.1</span> - Как я могу задать ключи для столбцов <code>origin</code> и <code>dest</code>?</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setkey</span>(flights, origin, dest)
<span class="kw">head</span>(flights)
<span class="co">#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin</span>
<span class="co"># 1: 2014     1   2      724        -2      810       -25         0      EV  N11547   4373    EWR</span>
<span class="co"># 2: 2014     1   3     2313        88        9        79         0      EV  N18120   4470    EWR</span>
<span class="co"># 3: 2014     1   4     1526       220     1618       211         0      EV  N11184   4373    EWR</span>
<span class="co"># 4: 2014     1   4      755        35      848        19         0      EV  N14905   4551    EWR</span>
<span class="co"># 5: 2014     1   5      817        47      921        42         0      EV  N19966   4470    EWR</span>
<span class="co"># 6: 2014     1   5     2301        66        2        62         0      EV  N19966   4682    EWR</span>
<span class="co">#    dest air_time distance hour min</span>
<span class="co"># 1:  ALB       30      143    7  24</span>
<span class="co"># 2:  ALB       29      143   23  13</span>
<span class="co"># 3:  ALB       32      143   15  26</span>
<span class="co"># 4:  ALB       32      143    7  55</span>
<span class="co"># 5:  ALB       26      143    8  17</span>
<span class="co"># 6:  ALB       31      143   23   1</span>

## or alternatively
<span class="co"># setkeyv(flights, c(&quot;origin&quot;, &quot;dest&quot;)) # provide a character vector of column names</span>

<span class="kw">key</span>(flights)
<span class="co"># [1] &quot;origin&quot; &quot;dest&quot;</span></code></pre></div>
<ul>
<li>Таблица <em>data.table</em> сортируется сначала по <code>origin</code>, а затем по <code>dest</code> <em>по ссылке</em>.</li>
</ul>
</div>
<div id="----------jfk-----mia" class="section level4">
<h4><span class="header-section-number">2.3.3.2</span> - Выбрать все строки, для которых первый <em>ключевой</em> столбец имеет значение “JFK”, а второй - “MIA”</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;MIA&quot;</span>)]
<span class="co">#       year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin</span>
<span class="co">#    1: 2014     1   1     1509        -1     1828       -17         0      AA  N5FJAA    145    JFK</span>
<span class="co">#    2: 2014     1   1      917         7     1227        -8         0      AA  N5DWAA   1085    JFK</span>
<span class="co">#    3: 2014     1   1     1227         2     1534        -1         0      AA  N635AA   1697    JFK</span>
<span class="co">#    4: 2014     1   1      546         6      853         3         0      AA  N5CGAA   2243    JFK</span>
<span class="co">#    5: 2014     1   1     1736         6     2043       -12         0      AA  N397AA   2351    JFK</span>
<span class="co">#   ---                                                                                             </span>
<span class="co"># 2746: 2014    10  31     1659        -1     1956       -22         0      AA  N5FNAA   2351    JFK</span>
<span class="co"># 2747: 2014    10  31      826        -3     1116       -20         0      AA  N5EYAA   1085    JFK</span>
<span class="co"># 2748: 2014    10  31      647         2      941       -17         0      AA  N5BTAA   1101    JFK</span>
<span class="co"># 2749: 2014    10  31      542        -3      834       -12         0      AA  N3ETAA   2299    JFK</span>
<span class="co"># 2750: 2014    10  31     1944        29     2232         4         0      AA  N5FSAA   2387    JFK</span>
<span class="co">#       dest air_time distance hour min</span>
<span class="co">#    1:  MIA      161     1089   15   9</span>
<span class="co">#    2:  MIA      166     1089    9  17</span>
<span class="co">#    3:  MIA      164     1089   12  27</span>
<span class="co">#    4:  MIA      157     1089    5  46</span>
<span class="co">#    5:  MIA      154     1089   17  36</span>
<span class="co">#   ---                                </span>
<span class="co"># 2746:  MIA      148     1089   16  59</span>
<span class="co"># 2747:  MIA      146     1089    8  26</span>
<span class="co"># 2748:  MIA      150     1089    6  47</span>
<span class="co"># 2749:  MIA      150     1089    5  42</span>
<span class="co"># 2750:  MIA      146     1089   19  44</span></code></pre></div>
</div>
<div id="----" class="section level4">
<h4><span class="header-section-number">2.3.3.3</span> Как здесь работает создание поднабора?</h4>
<ul>
<li><p>Важно понимать, как это работает изнутри. “JFK” сначала сопоставляется с первым ключевым столбцом <code>origin</code>. И среди этих сопоставленных строк “MIA” сопоставляется со вторым ключевым столбцом <code>dest</code> для получения индексов строк, где <code>origin</code> и <code>dest</code> совпадают с данными значениями.</p></li>
<li><p>Поскольку элемент <code>j</code> не задан, мы просто возвращаем <em>все столбцы</em> для этих индексов строк.</p></li>
</ul>
</div>
<div id="---------origin---jfk" class="section level4">
<h4><span class="header-section-number">2.3.3.4</span> - Выбрать все строки, для которых только первый ключевой столбец <code>origin</code> соответствует значению “JFK”</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">key</span>(flights)
<span class="co"># [1] &quot;origin&quot; &quot;dest&quot;</span>

flights[.(<span class="st">&quot;JFK&quot;</span>)] ## or in this case simply flights[&quot;JFK&quot;], for convenience
<span class="co">#        year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin</span>
<span class="co">#     1: 2014     1   1     2011        10     2308         4         0      B6  N766JB     65    JFK</span>
<span class="co">#     2: 2014     1   2     2215       134      145       161         0      B6  N507JB     65    JFK</span>
<span class="co">#     3: 2014     1   7     2006         6     2314         6         0      B6  N652JB     65    JFK</span>
<span class="co">#     4: 2014     1   8     2009        15     2252       -15         0      B6  N613JB     65    JFK</span>
<span class="co">#     5: 2014     1   9     2039        45     2339        32         0      B6  N598JB     65    JFK</span>
<span class="co">#    ---                                                                                             </span>
<span class="co"># 81479: 2014    10  31      800         0     1040       -18         0      DL  N915AT   2165    JFK</span>
<span class="co"># 81480: 2014    10  31     1932         1     2228        -8         0      B6  N516JB    225    JFK</span>
<span class="co"># 81481: 2014    10  31     1443        -2     1726       -22         0      B6  N334JB    325    JFK</span>
<span class="co"># 81482: 2014    10  31      957        -8     1255        -5         0      B6  N637JB    925    JFK</span>
<span class="co"># 81483: 2014    10  31      831        -4     1118       -18         0      B6  N595JB   1025    JFK</span>
<span class="co">#        dest air_time distance hour min</span>
<span class="co">#     1:  ABQ      280     1826   20  11</span>
<span class="co">#     2:  ABQ      252     1826   22  15</span>
<span class="co">#     3:  ABQ      269     1826   20   6</span>
<span class="co">#     4:  ABQ      259     1826   20   9</span>
<span class="co">#     5:  ABQ      267     1826   20  39</span>
<span class="co">#    ---                                </span>
<span class="co"># 81479:  TPA      142     1005    8   0</span>
<span class="co"># 81480:  TPA      149     1005   19  32</span>
<span class="co"># 81481:  TPA      145     1005   14  43</span>
<span class="co"># 81482:  TPA      149     1005    9  57</span>
<span class="co"># 81483:  TPA      145     1005    8  31</span></code></pre></div>
<ul>
<li>Поскольку мы не задали никаких значений для второго ключевого столбца <code>dest</code>, происходит лишь сопоставление “JFK” в первом ключевом столбце <code>origin</code> и возврат всех соответствующих строк.</li>
</ul>
</div>
<div id="---------dest---mia" class="section level4">
<h4><span class="header-section-number">2.3.3.5</span> - Выбрать все строки, для которых только второй ключевой столбец <code>dest</code> соответствует значению “MIA”</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="kw">unique</span>(origin), <span class="st">&quot;MIA&quot;</span>)]
<span class="co">#       year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin</span>
<span class="co">#    1: 2014     1   1     1655        -5     2003       -17         0      AA  N5CFAA    172    EWR</span>
<span class="co">#    2: 2014     1   1      607        -3      905       -10         0      AA  N5DMAA   1205    EWR</span>
<span class="co">#    3: 2014     1   1     1125        -5     1427        -8         0      AA  N3AGAA   1623    EWR</span>
<span class="co">#    4: 2014     1   1     1533        43     1840        42         0      UA  N491UA    244    EWR</span>
<span class="co">#    5: 2014     1   1     2130        60       29        49         0      UA  N476UA    308    EWR</span>
<span class="co">#   ---                                                                                             </span>
<span class="co"># 9924: 2014    10  31     1348       -11     1658        -8         0      AA  N3AMAA   2283    LGA</span>
<span class="co"># 9925: 2014    10  31      950        -5     1257       -11         0      AA  N3LFAA   2287    LGA</span>
<span class="co"># 9926: 2014    10  31      658        -2     1017        10         0      AA  N3HNAA   2451    LGA</span>
<span class="co"># 9927: 2014    10  31     1913        -2     2212       -16         0      AA  N3LFAA   2455    LGA</span>
<span class="co"># 9928: 2014    10  31     1530         1     1839       -11         0      US  N768US   1715    LGA</span>
<span class="co">#       dest air_time distance hour min</span>
<span class="co">#    1:  MIA      161     1085   16  55</span>
<span class="co">#    2:  MIA      154     1085    6   7</span>
<span class="co">#    3:  MIA      157     1085   11  25</span>
<span class="co">#    4:  MIA      155     1085   15  33</span>
<span class="co">#    5:  MIA      162     1085   21  30</span>
<span class="co">#   ---                                </span>
<span class="co"># 9924:  MIA      157     1096   13  48</span>
<span class="co"># 9925:  MIA      150     1096    9  50</span>
<span class="co"># 9926:  MIA      156     1096    6  58</span>
<span class="co"># 9927:  MIA      156     1096   19  13</span>
<span class="co"># 9928:  MIA      164     1096   15  30</span></code></pre></div>
</div>
<div id="--" class="section level4">
<h4><span class="header-section-number">2.3.3.6</span> Что здесь происходит?</h4>
<ul>
<li><p>Прочтите еще раз пункт “Как здесь работает создание поднабора?”. Значение для второго ключевого столбца “MIA” должно найти соответствия в ключевом столбце <code>dest</code> среди строк, <em>для которых есть соответствие по первому ключевому столбцу <code>origin</code></em>. Мы не можем пропустить значения предшествующих ключевых столбцов. Поэтому мы задаем все уникальные значения ключевого столбца <code>origin</code>.</p></li>
<li><p>“MIA” автоматически повторяется, чтобы соответствовать длине <code>unique(origin)</code>, которая равна 3.</p></li>
</ul>
</div>
</div>
</div>
<div id="---j--by" class="section level2">
<h2><span class="header-section-number">2.4</span> 2. Комбинирование ключей с <code>j</code> и <code>by</code></h2>
<p>По сути, все, что мы видели до сих пор - это получение индексов строк в <code>i</code>, но с использованием другого метода - с помощью ключей. Не удивительно, что мы можем делать то же самое в <code>j</code> и <code>by</code>, как мы видели в предыдущих виньетках. Мы покажем это на нескольких примерах.</p>
<div id="a---j" class="section level3">
<h3><span class="header-section-number">2.4.1</span> a) Выбор в <code>j</code></h3>
<div id="--arr_delay---data.table--origin-lga--dest-tpa." class="section level4">
<h4><span class="header-section-number">2.4.1.1</span> Вернуть столбец <code>arr_delay</code> как таблицу <em>data.table</em>, соответствующую <code>origin = &quot;LGA&quot;</code> и <code>dest = &quot;TPA&quot;</code>.</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">key</span>(flights)
<span class="co"># [1] &quot;origin&quot; &quot;dest&quot;</span>
flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), .(arr_delay)]
<span class="co">#       arr_delay</span>
<span class="co">#    1:         1</span>
<span class="co">#    2:        14</span>
<span class="co">#    3:       -17</span>
<span class="co">#    4:        -4</span>
<span class="co">#    5:       -12</span>
<span class="co">#   ---          </span>
<span class="co"># 1848:        39</span>
<span class="co"># 1849:       -24</span>
<span class="co"># 1850:       -12</span>
<span class="co"># 1851:        21</span>
<span class="co"># 1852:       -11</span></code></pre></div>
<ul>
<li><p><em>Индексы строк</em>, соответствующих <code>origin = &quot;LGA&quot;</code> и <code>dest = &quot;TPA&quot;</code>, получены с использованием <em>поднабора на основе ключей</em>.</p></li>
<li><p>Как только у нас есть индексы строк, мы смотрим на <code>j</code>, где требуется только столбец <code>arr_delay</code>. Поэтому мы просто выбираем столбец <code>arr_delay</code> для этих индексов строк точно таким же образом, как мы видели в виньетке “Введение в data.table”.</p></li>
<li><p>Мы могли бы также получить результат с помощью <code>with = FALSE</code>.</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), <span class="st">&quot;arr_delay&quot;</span>, with=<span class="ot">FALSE</span>]</code></pre></div>
</div>
</div>
<div id="b--" class="section level3">
<h3><span class="header-section-number">2.4.2</span> b) Цепочки операций</h3>
<div id="-----------." class="section level5">
<h5><span class="header-section-number">2.4.2.0.1</span> - Для результатов, полученных выше, использовать цепочку операций для сортировки столбца по убыванию.</h5>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), .(arr_delay)][<span class="kw">order</span>(-arr_delay)]
<span class="co">#       arr_delay</span>
<span class="co">#    1:       486</span>
<span class="co">#    2:       380</span>
<span class="co">#    3:       351</span>
<span class="co">#    4:       318</span>
<span class="co">#    5:       300</span>
<span class="co">#   ---          </span>
<span class="co"># 1848:       -40</span>
<span class="co"># 1849:       -43</span>
<span class="co"># 1850:       -46</span>
<span class="co"># 1851:       -48</span>
<span class="co"># 1852:       -49</span></code></pre></div>
</div>
</div>
<div id="c-----j" class="section level3">
<h3><span class="header-section-number">2.4.3</span> c) Вычислить или <em>выполнить</em> в <code>j</code></h3>
<div id="-----origin-lga--dest-tpa." class="section level4">
<h4><span class="header-section-number">2.4.3.1</span> - Найти максимальную задержку прибытия, соответствующую <code>origin = &quot;LGA&quot;</code> и <code>dest = &quot;TPA&quot;</code>.</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), <span class="kw">max</span>(arr_delay)]
<span class="co"># [1] 486</span></code></pre></div>
<ul>
<li>Мы можем убедиться, что результат совпадает с первым значением (486) из предыдущего примера.</li>
</ul>
</div>
</div>
<div id="d--------j" class="section level3">
<h3><span class="header-section-number">2.4.4</span> d) <em>Частичное присваивание</em> по ссылке с использованием <code>:=</code> в <code>j</code></h3>
<p>Мы уже видели этот пример в виньетке “Семантика ссылок”. Давайте взглянем на все часы <code>hours</code>, доступные в таблице <em>data.table</em> <code>flights</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get all &#39;hours&#39; in flights</span>
flights[, <span class="kw">sort</span>(<span class="kw">unique</span>(hour))]
<span class="co">#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</span></code></pre></div>
<p>Мы видим, что данные имеют всего <code>25</code> уникальных значений. Присутствуют и 0, и 24. Давайте двигаться дальше и заменим 24 на 0, но в этот раз с использованием <em>ключа</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setkey</span>(flights, hour)
<span class="kw">key</span>(flights)
<span class="co"># [1] &quot;hour&quot;</span>
flights[.(<span class="dv">24</span>), hour :<span class="er">=</span><span class="st"> </span>0L]
<span class="kw">key</span>(flights)
<span class="co"># NULL</span></code></pre></div>
<ul>
<li><p>Сперва мы сделали столбец <code>hour</code> ключом <code>key</code> . Это переупорядочило <code>flights</code> по столбцу <code>hour</code> и пометило этот столбец как <code>key</code>.</p></li>
<li><p>Теперь мы можем создавать поднаборы по столбцу <code>hour</code>, используя <code>.()</code>. Мы выбрали значение <em>24</em> и получили соответствующие индексы строк.</p></li>
<li><p>И для этих индексов мы заменили столбец <code>key</code> значением 0.</p></li>
<li><p>После того, как мы заменили значения <em>ключевого</em> столбца, таблица <em>data.table</em> <code>flights</code> больше не является упорядоченной по столбцу <code>hour</code>. Таким образом, ключ был автоматически удален путем установки в <code>NULL</code>.</p></li>
</ul>
<p>Теперь значений 24 не должно быть в столбце <code>hour</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[, <span class="kw">sort</span>(<span class="kw">unique</span>(hour))]
<span class="co">#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23</span></code></pre></div>
</div>
<div id="e----by" class="section level3">
<h3><span class="header-section-number">2.4.5</span> e) Агрегирование с использованием <code>by</code></h3>
<p>Давайте снова сделаем ключом столбцы <code>origin</code>, <code>dest</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setkey</span>(flights, origin, dest)
<span class="kw">key</span>(flights)
<span class="co"># [1] &quot;origin&quot; &quot;dest&quot;</span></code></pre></div>
<div id="--------origin-jfk.----month" class="section level4">
<h4><span class="header-section-number">2.4.5.1</span> - Получить максимальную задержку вылета за каждый месяц для <code>origin = &quot;JFK&quot;</code>. Упорядочить результат по <code>month</code></h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ans &lt;-<span class="st"> </span>flights[<span class="st">&quot;JFK&quot;</span>, <span class="kw">max</span>(dep_delay), keyby=month]
<span class="kw">head</span>(ans)
<span class="co">#    month   V1</span>
<span class="co"># 1:     1  881</span>
<span class="co"># 2:     2 1014</span>
<span class="co"># 3:     3  920</span>
<span class="co"># 4:     4 1241</span>
<span class="co"># 5:     5  853</span>
<span class="co"># 6:     6  798</span>
<span class="kw">key</span>(ans)
<span class="co"># [1] &quot;month&quot;</span></code></pre></div>
<ul>
<li><p>Мы выбираем поднабор по <em>ключевому</em> столбцу <code>origin</code> для получения <em>индексов строк</em>, соответствующих “JFK”.</p></li>
<li><p>После того, как мы получили индексы строк, нам нужно лишь два столбца - <code>month</code>, чтобы выполнить по нему группировку, и <code>dep_delay</code> для получения <code>max()</code> в каждой группе. Поэтому оптимизация запросов в <em>data.table</em> приведет к выбору только этих двух столбцов для соответствующих индексов строк, полученных в <code>i</code>, для скорости и эффективного использования памяти.</p></li>
<li><p>И на этом поднаборе мы выполняем группировку по <code>month</code> и рассчитываем <code>max(dep_delay)</code>.</p></li>
<li><p>Мы используем <code>keyby</code>, чтобы автоматически сделать <code>month</code> ключом для результата. Теперь мы понимаем, что это значит. В добавок к упорядочиванию, это также делает <code>month</code> <em>ключевым</em> столбцом.</p></li>
</ul>
</div>
</div>
</div>
<div id="----mult--nomatch" class="section level2">
<h2><span class="header-section-number">2.5</span> 3. Дополнительные аргументы - <code>mult</code> и <code>nomatch</code></h2>
<div id="a--mult" class="section level3">
<h3><span class="header-section-number">2.5.1</span> a) Аргумент <code>mult</code></h3>
<p>Для каждого запроса при помощи аргумента <code>mult</code> мы можем выбрать, должны ли быть возвращены <em>“все”</em> соответствующие строки, или только <em>“первая”</em> или <em>“последняя”</em>. Значение по умолчанию <em>“все”</em> - это то, что мы видели до сих пор.</p>
<div id="---------origin--jfk--dest--mia" class="section level4">
<h4><span class="header-section-number">2.5.1.1</span> - Выбрать только первую строку из всех строк, для которых <code>origin</code> соответствует “JFK” и <code>dest</code> соответствует “MIA”</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;MIA&quot;</span>), mult=<span class="st">&quot;first&quot;</span>]
<span class="co">#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin</span>
<span class="co"># 1: 2014     1   1      546         6      853         3         0      AA  N5CGAA   2243    JFK</span>
<span class="co">#    dest air_time distance hour min</span>
<span class="co"># 1:  MIA      157     1089    5  46</span></code></pre></div>
</div>
<div id="---------origin--lga-jfk-ewr--dest--xna" class="section level4">
<h4><span class="header-section-number">2.5.1.2</span> - Выбрать только последнюю строку из всех строк, для которых <code>origin</code> соответствует “LGA”, “JFK”, “EWR” и <code>dest</code> соответствует “XNA”</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="kw">c</span>(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;EWR&quot;</span>), <span class="st">&quot;XNA&quot;</span>), mult=<span class="st">&quot;last&quot;</span>]
<span class="co">#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin</span>
<span class="co"># 1: 2014     5  23     1803       163     2003       148         0      MQ  N515MQ   3553    LGA</span>
<span class="co"># 2:   NA    NA  NA       NA        NA       NA        NA        NA      NA      NA     NA    JFK</span>
<span class="co"># 3: 2014     2   3     1208       231     1516       268         0      EV  N14148   4419    EWR</span>
<span class="co">#    dest air_time distance hour min</span>
<span class="co"># 1:  XNA      158     1147   18   3</span>
<span class="co"># 2:  XNA       NA       NA   NA  NA</span>
<span class="co"># 3:  XNA      184     1131   12   8</span></code></pre></div>
<ul>
<li><p>Запрос “JFK”, “XNA” не соответствует никаким строкам в таблице <code>flights</code>, поэтому возвращается <code>NA</code>.</p></li>
<li><p>И снова, запрос для второго ключевого столбца <code>dest</code>, “XNA”, повторяется, чтобы соответствовать длине первого ключевого столбца <code>origin</code>, которая равна 3.</p></li>
</ul>
</div>
</div>
<div id="b--nomatch" class="section level3">
<h3><span class="header-section-number">2.5.2</span> b) Аргумент <code>nomatch</code></h3>
<p>Мы можем выбрать при помощи аргумента <code>nomatch</code>, должны ли запросы, для которых нет соответствий, возвращать <code>NA</code> или вообще быть пропущенными.</p>
<div id="----------" class="section level4">
<h4><span class="header-section-number">2.5.2.1</span> - Выбрать только те строки из предыдущего примера, для которых есть соответствия</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lights[.(<span class="kw">c</span>(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;EWR&quot;</span>), <span class="st">&quot;XNA&quot;</span>), mult=<span class="st">&quot;last&quot;</span>, nomatch =<span class="st"> </span>0L]
<span class="co">#    year month day dep_time dep_delay arr_time arr_delay cancelled carrier tailnum flight origin</span>
<span class="co"># 1: 2014     5  23     1803       163     2003       148         0      MQ  N515MQ   3553    LGA</span>
<span class="co"># 2: 2014     2   3     1208       231     1516       268         0      EV  N14148   4419    EWR</span>
<span class="co">#    dest air_time distance hour min</span>
<span class="co"># 1:  XNA      158     1147   18   3</span>
<span class="co"># 2:  XNA      184     1131   12   8</span></code></pre></div>
<ul>
<li><p>Значением по умолчанию для <code>nomatch</code> является <code>NA</code>. Установка <code>nomatch = 0L</code> приведет к пропуску запросов, для которых нет соответствий.</p></li>
<li><p>Для запроса “JFK”, “XNA” нет соответствующих строк в таблице <code>flights</code>, поэтому он пропускается.</p></li>
</ul>
</div>
</div>
</div>
<div id="------" class="section level2">
<h2><span class="header-section-number">2.6</span> 4. Бинарный поиск в сравнении со сканированием вектора</h2>
<p>До сих пор мы видели, как можно устанавливать и использовать ключи для создания поднаборов. Но в чем преимущество? Например, вместо:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># key by origin,dest columns</span>
flights[.(<span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;MIA&quot;</span>)]</code></pre></div>
<p>мы можем выполнить:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[origin ==<span class="st"> &quot;JFK&quot;</span> &amp;<span class="st"> </span>dest ==<span class="st"> &quot;MIA&quot;</span>]</code></pre></div>
<p>Одним из преимуществ, вероятно, является меньшее количество кода. Но, более того, <em>создание поднаборов на основе бинарного поиска</em> является <strong>невероятно быстрым</strong>.</p>
<div id="a---" class="section level3">
<h3><span class="header-section-number">2.6.1</span> a) Производительность бинарного поиска</h3>
<p>В качестве примера, давайте создадим таблицу <code>data.table</code> с 20 млн. строк и тремя столбцами, задав столбцы <code>x</code> и <code>y</code> в качестве ключа.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(2L)
N =<span class="st"> </span>2e7L
DT =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">x =</span> <span class="kw">sample</span>(letters, N, <span class="ot">TRUE</span>), 
                <span class="dt">y =</span> <span class="kw">sample</span>(1000L, N, <span class="ot">TRUE</span>), 
                <span class="dt">val=</span><span class="kw">runif</span>(N), <span class="dt">key =</span> <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>))
<span class="kw">print</span>(<span class="kw">object.size</span>(DT), <span class="dt">units=</span><span class="st">&quot;Mb&quot;</span>)
<span class="co"># 381.5 Mb</span>

<span class="kw">key</span>(DT)
<span class="co"># [1] &quot;x&quot; &quot;y&quot;</span></code></pre></div>
<p><code>DT</code> весит ~380MB. Это не так уж много, но достаточно для иллюстрации.</p>
<p>Как мы видели в виньетке “Введение в data.table”, мы можем выбрать те строки, где <code>x = &quot;g&quot;</code> и <code>y = 877</code>, следующим образом:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## (1) Usual way of subsetting - vector scan approach
t1 &lt;-<span class="st"> </span><span class="kw">system.time</span>(ans1 &lt;-<span class="st"> </span>DT[x ==<span class="st"> &quot;g&quot;</span> &amp;<span class="st"> </span>y ==<span class="st"> </span>877L])
t1
<span class="co">#    user  system elapsed </span>
<span class="co">#   0.871   0.022   0.919</span>
<span class="kw">head</span>(ans1)
<span class="co">#    x   y       val</span>
<span class="co"># 1: g 877 0.3946652</span>
<span class="co"># 2: g 877 0.9424275</span>
<span class="co"># 3: g 877 0.7068512</span>
<span class="co"># 4: g 877 0.6959935</span>
<span class="co"># 5: g 877 0.9673482</span>
<span class="co"># 6: g 877 0.4842585</span>
<span class="kw">dim</span>(ans1)
<span class="co"># [1] 761   3</span></code></pre></div>
<p>Теперь давайте попробуем выбрать поднабор с использованием ключей.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## (2) Subsetting using keys
t2 &lt;-<span class="st"> </span><span class="kw">system.time</span>(ans2 &lt;-<span class="st"> </span>DT[.(<span class="st">&quot;g&quot;</span>, 877L)])
t2
<span class="co">#    user  system elapsed </span>
<span class="co">#   0.001   0.000   0.002</span>
<span class="kw">head</span>(ans2)
<span class="co">#    x   y       val</span>
<span class="co"># 1: g 877 0.3946652</span>
<span class="co"># 2: g 877 0.9424275</span>
<span class="co"># 3: g 877 0.7068512</span>
<span class="co"># 4: g 877 0.6959935</span>
<span class="co"># 5: g 877 0.9673482</span>
<span class="co"># 6: g 877 0.4842585</span>
<span class="kw">dim</span>(ans2)
<span class="co"># [1] 761   3</span>

<span class="kw">identical</span>(ans1$val, ans2$val)
<span class="co"># [1] TRUE</span></code></pre></div>
<p>Произошло ускорение в <strong>~460 раз</strong>!</p>
</div>
<div id="b-----data.table-----" class="section level3">
<h3><span class="header-section-number">2.6.2</span> b) Почему использование ключей в <em>data.table</em> приводит к молниеносному созданию поднаборов?</h3>
<p>Чтобы это понять, давайте сперва рассмотрим подход, состоящий в <em>сканировании вектора</em> (метод 1).</p>
<div id="-" class="section level4">
<h4><span class="header-section-number">2.6.2.1</span> Сканирование вектора:</h4>
<ul>
<li><p>Происходит поиск значения “g” по столбцу <code>x</code> строка за строкой по всем 20 млн. строк. Это приводит к созданию логического вектора длиной 20 млн. со значениями <code>TRUE</code>, <code>FALSE</code> или <code>NA</code>, которые соответствуют значениям <code>x</code>.</p></li>
<li><p>Аналогичным образом, по столбцу <code>y</code> ищутся значения <code>877</code> среди всех 20 млн. строк и сохраняются в другом логическом векторе.</p></li>
<li><p>Поэлементная операция <code>&amp;</code> выполняется на промежуточных логических векторах, и возвращаются все строки, для которых значение выражения равно <code>TRUE</code>.</p></li>
</ul>
<p>Это то, что мы называем сканированием вектора. И это весьма неэффективно, особенно в случае больших таблиц, а также когда требуется повторное создание поднаборов, потому что каждый раз происходит повторное сканирование всех строк.</p>
<p>Теперь давайте рассмотрим бинарный поиск (метод 2). Напомним, из раздела “Свойства ключей”, что установка ключей переупорядочивает таблицу <em>data.table</em> по ключевым столбцам. Поскольку данные отсортированы, нам не нужно осуществлять сканирование по всей длине столбца! Вместо этого мы можем использовать бинарный поиск значения за время <code>O(log n)</code>, в отличие от времени <code>O(n)</code> в случае сканирования вектора, где <code>n</code> является числом строк в таблице <em>data.table</em></p>
</div>
<div id="-" class="section level4">
<h4><span class="header-section-number">2.6.2.2</span> Бинарный поиск:</h4>
<p>Вот очень простой пример. Рассмотрим (упорядоченные) значения, показанные ниже:</p>
<pre><code>1, 5, 10, 19, 22, 23, 30</code></pre>
<p>Предположим, мы хотели бы найти позицию, соответствующую значению 1, используя бинарный поиск - потому что мы знаем, что данные <em>отсортированы</em>.</p>
<ul>
<li><p>Начинаем со значения в середине = 19. 1 == 19? Нет. 1 &lt; 19.</p></li>
<li><p>Поскольку значение, которое мы ищем, меньше 19, оно должно быть где-то до 19. Таким образом, мы можем отбросить другую половину, которая &gt;= 19.</p></li>
<li><p>Наш набор значений теперь сократился до 1, 5, 10. Еще раз возьмем значение в середине = 5. 1 == 5? Нет. 1 &lt; 5.</p></li>
<li><p>Наш набор значений сократился до 1. 1 == 1? Да. Соответствующий индекс также равен 1. И это единственное соответствие.</p></li>
</ul>
<p>С другой стороны, сканирование вектора привело бы к проверке всех значений, количество которых 7.</p>
<p>Видно, что с каждым поиском мы уменьшаем количество элементов в два раза. Поэтому выбор поднаборов на основе бинарного поиска является невероятно быстрым. Поскольку строки каждого столбца <em>data.tables</em> находятся в смежных ячейках памяти, операции выполняются способом, эффективным с точки зрения использования кэша (что также способствует большей скорости).</p>
<p>Кроме того, поскольку мы получаем индексы соответствующих строк непосредственно, без создания этих больших логических векторов (равных по размеру числу строк в таблице <em>data.table</em>), также более эффективно используется память.</p>
</div>
</div>
</div>
<div id="-1" class="section level2">
<h2><span class="header-section-number">2.7</span> Резюме</h2>
<p>В этой виньетке мы изучили другой способ выбора поднаборов строк в <code>i</code> путем установки ключей в таблице <em>data.table</em>. Установка ключей позволяет нам выполнять молниеносное создание поднаборов при помощи использования <em>бинарного поиска</em>. В частности, мы увидели, как:</p>
<ul>
<li><p>устанавливать ключ и создавать поднаборы в таблице <em>data.table</em>, используя ключ</p></li>
<li><p>создавать поднаборы, используя ключи, которые задают индексы строк в <code>i</code>, но гораздо быстрее</p></li>
<li><p>комбинировать создание поднаборов по ключу с <code>j</code> и <code>by</code>. Обратите внимание, что операции <code>j</code> и <code>by</code> - те же, что и раньше.</p></li>
</ul>
<p>Создание поднаборов на основе ключа является <strong>невероятно быстрым</strong> и особенно полезным, когда задача включает <em>повторяющееся создание поднаборов</em>.</p>
<p>Вообще, мы не обязаны устанавливать и использовать ключи для операций агрегирования, пока наши данные не являются очень большими и/или задача не требует повторяющегося создания поднаборов, когда подход с использованием ключей будет заметно более производительным.</p>
<p>Тем не менее, установка ключей имеет важное значение для объединения двух таблиц <code>data.table</code>, что является предметом обсуждения в виньетке “Joins and rolling joins” (еще не написанной - прим. пер.). Мы расширим концепцию создания поднаборов на основе ключей для объединения двух таблиц <code>data.table</code>, основанного на ключевых столбцах.</p>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="01_data.table_intro.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="03_data.table_reference.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
