---
title: "Введение в data.table"
output: html_document
date: 2015-06-24
---

```{r}
library(data.table)
```

Эта виньетка представляет собой введение в синтакс *data.table*, его общий вид, способы создания поднаборов строк (*subset*), выбора и вычисления колонок (*select*, *compute*), агрегирования по группам (*by group*). Знакомство с базовой структурой данных *data.frame* является полезным, но не обязательным.

## Анализ данных с data.table

Все операции манипулирования данными, такие как *subset*, *group*, *update*, *join* и др., по сути взаимосвязаны. С учетом этого, вместе они обеспечивают:

* краткий и согласованный синтаксис независимо от набора операций, которые вы хотели бы выполнить для достижения вашей конечной цели.

* плавное выполнение анализа без когнитивной нагрузки, связанной с помещением каждой операции в отдельную функцию из набора доступных функций для выполнения анализа.

* автоматическая и эффективная внутренняя оптимизация за счет точного знания, какие данные нужны для каждой операции, что делает вычисления очень быстрыми и экономно расходующими память.

Вкратце, если вы заинтересованы в радикальном сокращении программного кода и времени вычислений, то этот пакет для вас. Философия, которой следует *data.table*, делает это возможным. Наша цель состоит в иллюстрации этого в серии виньеток.


## Данные

В этой виньетке мы используем набор данных [NYC-flights14](https://github.com/arunsrinivasan/flights/wiki/NYC-Flights-2014-data). Он содержит данные о времени полетов от [Bureau of Transporation Statistics](http://www.transtats.bts.gov/DL_SelectFields.asp?Table_ID=236) для всех рейсов из аэропортов Нью-Йорка в 2014 г. (по аналогии с [nycflights13](https://github.com/hadley/nycflights13)). Данные доступны только для с января по октябрь 2014 г.

Мы можем использовать быструю функцию для чтения `fread` из *data.table* для непосредственной загрузки набора данных *flights*:

```{r}
flights <- fread("https://raw.githubusercontent.com/wiki/arunsrinivasan/flights/NYCflights14/flights14.csv")
flights
dim(flights)
```

Так как мы будем использовать этот набор данных во всех виньетках, может быть, лучше скачать файл один раз и затем загрузить его с диска.


## Введение

В этой виньетке мы:

* начнем с основ - что такое пакет *data.table*, его общий вид, способы выделение поднаборов строк, выбор и вычисление колонок.

* затем перейдем к выполнению агрегирования данных по группам.



## 1. Основы

### a) Что такое *data.table*?

*data.table* является пакетов, обеспечивающим **улучшенную версию** таблиц данных *data.frames*. В разделе "Данные" мы уже создали таблицу *data.table* при помощи `fread()`. Мы также можем создать таблицу, использую функцию `data.table()`. Пример:

```{r}
DT = data.table(ID = c("b","b","b","a","a","c"), a = 1:6, b = 7:12, c=13:18)
DT
class(DT$ID)
```

Вы также можете конвертировать существующие объекты в *data.table*, используя `as.data.table()`.


#### Обратите внимание, что:

* В отличие от *data.frames*, столбцы символьного типа по умолчанию *никогда* не конвертируются в факторы (`factor`).

* Номера строк выводятся вместе с `:` для их визуального отделения от первого столбца.

* Когда количество строк для вывода превышает значение глобального параметра `datatable.print.nrows` (по умолчанию оно равно 100), автоматически выводятся только первые 5 и последний 5 строк (как можно видеть в разделе "Данные").

```{r}
getOption("datatable.print.nrows")
```

* *data.table* никогда не устанавливает имена строк (*row names*). Почему - мы увидим в виньетке “Keys and fast binary search based subset”.


### b) Общий вид - каким образом реализованы улучшения *data.table*?

По сравнению с *data.frame*, мы можете сделать *гораздо больше*, чем выбор строк и столбцов в таблице при помощи `[ ... ]`. Для понимания этого посмотрим на общий вид синтаксиса *data.table*, как показано ниже:

```{r, eval=FALSE}
DT[i, j, by]

##   R:      i                 j        by
## SQL:  where   select | update  group by
```

Пользователи с опытом использования SQLL могут сразу понять этот синтаксис.

#### Как прочитать это (вслух):

Взять `DT`, выбрать строки при помощи `i`, затем вычислить `j`, сгруппировав по `by`.

Давайте начнем с рассмотрения `i` и `j` - выбора строк и операций над столбцами.


### c) Выбор строк в `i`

#### - Выбрать все рейсы с начальной точкой (аэропортом) “JFK” за июнь.

```{r}
ans <- flights[origin == "JFK" & month == 6L]
head(ans)
```

* В таблице *data.table* к столбцам можно обращаться, как *если бы они были переменными*. Таким образом, мы просто обратились к `dest` (`origin` в примере выше - прим. пер.) и `month` как к переменным. Нам не нужно каждый раз добавлять префикс `flights$`. Тем не менее, использование `flights$dest` и `flights$month` будет нормально работать.

* Были рассчитаны *индексы строк*, удовлетворяющих условию `origin == "JFK" & month == 6L`, и, поскольку больше ничего делать не нужно, *data.table* просто возвратил все столбцы `flights` в соответствии с этими *индексами строк*.

* Запятая после условия также не требуется в составе `i`. Но `flights[dest == "JFK" & month == 6L, ]` также будет нормально работать. В *data.frames*, тем не менее, запятая обязательна.


#### - Выбрать первые две строки из таблицы `flights`.

```{r}
ans <- flights[1:2]
ans
```

* В этом случае условия нет. Индексы строк уже предоставлены в составе `i`. Поэтому мы возвращаем *data.table* со всеми столбцами из `flights` для этих индексов строк.

#### - Упорядочить `flights` сначала по столбцу `origin` в порядке возрастания, а затем  по `dest` в порядке убывания.

Мы можем использовать для этого базовую функцию R `order()`.

```{r}
ans <- flights[order(origin, -dest)]
head(ans)
```

#### Функция `order()` является внутренне оптимизированной

* Мы можем использовать "-" в таблице *data.table* для сортировки в порядке убывания. 
* Кроме того, `order(...)` в таблице *data.table* использует внутренний способ вычисления `forder()`, который гораздо быстрее, чем `base::order`. Вот небольшой пример, чтобы проиллюстрировать разницу.

```{r, eval=FALSE}
odt = data.table(col=sample(1e7))
(t1 <- system.time(ans1 <- odt[base::order(col)]))  ## uses order from base R
#    user  system elapsed 
#   8.610   0.056   8.708
(t2 <- system.time(ans2 <- odt[order(col)]))        ## uses data.table's forder
#    user  system elapsed 
#   0.526   0.024   0.553
(identical(ans1, ans2))
# [1] TRUE
```

Ускорение составило **~16x**. Мы обсудим быстрое упорядочивание в виньетке "data.table internals".

* Таким образом, вы можете улучшить производительность, используя хорошо знаковые функции.


### d) Выбор столбцов в `j`

#### - Выбрать столбец `arr_delay`, но вернуть как *вектор*.

```{r}
ans <- flights[, arr_delay]
head(ans)
```

* Поскольку можно обращаться к столбцам, как если бы они были переменными в таблице, мы напрямую обратились к *переменным*, которые хотим выбрать. Поскольку нам нужны *все строки*, мы просто пропустили `i`.

* Были возвращены *все* строки для столбца `arr_delay`.

#### - Выбрать столбец `arr_delay`, но вернуть как *data.table*.

```{r}
ans <- flights[, list(arr_delay)]
head(ans)
```

* Мы обернули переменные (имена столбцов) вызовом `list()`, что гарантирует возврат объекта *data.table*. В случае отдельного имени столбца, не обернутого в `list()`, вместо этого возвращается вектор, как было показано в предыдущем примере.

* *data.table* также позволяет использовать `.()`. Это *псевдоним* (alias) для `list()`. Используйте тот или иной вариант в зависимости от своих предпочтений.

Далее мы продолжим использовать `.()`.

*data.tables* (и *data.frames*) внутри являются списками со столбцами равной длины и с атрибутом класса. Разрешение `j` возвращать список позволяет конвертировать и возвращать *data.table* очень эффективно.

#### Совет

Пока `j-выражение` возвращает список, каждый элемент списка будет сконвертирован в столбец итоговой таблицы *data.table*. Это делает `j` допольно мощным средством, как мы вскоре увидим.

#### - Выбрать столбцы `arr_delay` и `dep_delay`.

```{r}
ans <- flights[, .(delay_arr = arr_delay, delay_dep = dep_delay)]
head(ans)

## alternatively
# ans <- flights[, list(arr_delay, dep_delay)]
```

* Оберните обе колонки в `.()` или `list()`. Вот и все.

#### - Выбрать столбцы `arr_delay` и `dep_delay` *и* переименовать их в `delay_arr` и `delay_dep`.

```{r}
ans <- flights[, .(delay_arr = arr_delay, delay_dep = dep_delay)]
head(ans)
```

Вот и все.


### e) Вычислить или *выполнить* в `j`

#### – сколько рейсов имели общую задержку (delay) < 0?

```{r}
ans <- flights[, sum((arr_delay + dep_delay) < 0)]
ans
```

#### Что здесь происходит?

* `j` в *data.table* может не только выбирать столбцы - этот элемент может обрабатывать *выражения*, т.е. *вычислять столбцы*. Это не удивительно, ведь к столбцам можно обращаться, как к переменным. Тогда мы должны быть способны выполнять вычисления, вызывая функции для этих переменных. И это именно то, что здесь происходит.

### f) Выбрать в `i` *и* выполнить в `j`

#### - Рассчитать среднюю задержку прибытия и отлета для всех рейсов с начальной точкой (аэропортом) “JFK” за июнь.

```{r}
ans <- flights[origin == "JFK" & month == 6L, 
               .(m_arr=mean(arr_delay), m_dep=mean(dep_delay))]
ans
```

* Мы сперва выбрали строки в `i`, найдя индексы, для которых значение `origin` равно “JFK”, а значение `month` равно 6. В этот момент мы *не выбрали* часть целой таблицы *data.table*, соответствующую этим строкам.

* Теперь мы смотрим на `j` и видим, что это выражение использует только два столбца. И мы должны рассчитать их средние значения `mean()`. Поэтому мы выбираем только столбцы с соответствующими строками и рассчитываем `mean()`.

Поскольку три компонента запроса (`i`, `j` и `by`) находятся вместе внутри `[...]`, *data.table* может видеть все три и оптимизировать запрос целиком перед вычислением, а не каждый по отдельности. Следовательно, мы можем избежать выбора всего поднабора данных для большей скорости и эффективного использования памяти.

#### - Как много вылетов было сделано в 2014 г. из аэропорта “JFK” за июнь?

```{r}
ans <- flights[origin == "JFK" & month == 6L, length(dest)]
ans
```

Функция `length()` требует передачи ей аргумента. Нам нужно лишь рассчитать количество строк в поднаборе. На самом деле, вы могли бы использовать любой столбец в качестве аргумента `length()`.

Этот тип операций встречается довольно часто, особенно в процессе группировки, как мы увидим в следующем разделе. *data.table* предоставляет для этого *специальный символ* `.N`.

#### Специальный символ `.N`

`.N` является специальной встроенной переменной, которая содержит число наблюдений в данной группе. Это особенно полезно в сочетании с `by`, как мы увидим в следующем разделе. При отсутствии оперции группировки просто возвращает количество строк в поднаборе.

Так что теперь мы можем выполнить эту задачу с помощью `.N` следующим образом:

```{r}
ans <- flights[origin == "JFK" & month == 6L, .N]
ans
```

* Еще раз: вы выбираем поднабор в `i` для получения индексов строк, для которых значение `origin` равно “JFK”, а значение `month` равно 6.

* Мы вилим, что `j` использует только `.N`и никаких столбцов. Поэтому весь поднабор на "материализовался". Мы просто вернули число строк в поднаборе (которое является всего лишь длиной индекса строк).

* Обратите внимание, что мы не обернули `.N` в `list()` или в `.()`, поэтому возвращен вектор.

Мы могли бы выполнить ту же операцию при помощи `nrow(flights[origin == "JFK" & month == 6L])`. Тем не менее, это привело бы сначала к выбору поднабора всей таблицы *data.table* для соответствующих индексов строк в `i`, *а затем* возврату числа строк при помощи `nrow()`, что является ненужным и неэффективным. Мы подробно рассмотрим этот и другие аспекты оптимизации в виньетке "data.table design".


### g) Отлично! Но как я могу ссылаться на столбцы по именам в `j` (как в *data.frame*)?

Вы можете ссылаться на имена столбцов в стиле *data.frame*, используя `with = FALSE` (таким же образом можно передавать номера столбцов - прим. пер.).

#### – Выбрать столбцы `arr_delay` и `dep_delay`, как в *data.frame*.

```{r}
ans <- flights[, c("arr_delay", "dep_delay"), with=FALSE]
head(ans)
```

Этот аргумент назват `with`, как функция R `with()`, из-за подобной функциональности. Предположим, у вас есть *data.frame* `DF`, и вы хотите выбрать все строки, для которых `x > 1`. 

```{r}
DF = data.frame(x = c(1,1,1,2,2,3,3,3), y = 1:8)

## (1) normal way
DF[DF$x > 1, ] # data.frame needs that ',' as well

## (2) using with
DF[with(DF, x > 1), ]
```

* Использование `with()` в (2) позволяет использовать столбец `x` в `DF` как переменную.

Отсюда и название аргумента в *data.table*. Установка `with=FALSE` отключает возможность ссылаться на столбцы как на переменые, тем самым восстанавливая "режим *data.frame* по умолчанию".

* Мы также можем исключать столбцы при помощи `-` или `!`. Например:

```{r, eval=FALSE}
## not run

# returns all columns except arr_delay and dep_delay
ans <- flights[, !c("arr_delay", "dep_delay"), with=FALSE]
# or
ans <- flights[, -c("arr_delay", "dep_delay"), with=FALSE]
```

* Начиная с v1.9.5+, мы также можем выбирать с указанием начального и конечного имен столбцов, например, `year:day` выберет первые три столбца.

```{r, eval=FALSE}
## not run

# returns year,month and day
ans <- flights[, year:day, with=FALSE]
# returns day, month and year
ans <- flights[, day:year, with=FALSE]
# returns all columns except year, month and day
ans <- flights[, -(year:day), with=FALSE]
ans <- flights[, !(year:day), with=FALSE]
```

Это особенно удобно при работе в интерактивном режиме.

`with = TRUE` установлено по умолчанию в *data.table*, потому что мы можем сделать гораздо больше, позволяя `j` обрабатывать выражения - особенно в комбинации с `by`, что мы сейчас увидим.



## 2. Агрегирования

ф